#!/usr/bin/python
################################################################################
# CONFIGURABLE PARAMETERS
################################################################################
# you can edit these as well, but you probably don't want to
# DO NOT EDIT ANYTHING BENEATH HERE UNLESS YOU KNOW WHAT YOU'RE DOING
################################################################################
# Load our Libraries
import sys, getopt, os.path, re, os
# Finished loading libraries
################################################################################
# some global variables:
GNUPLOT_TERMINAL='aqua'		# set this to x11 if your under linux.
GNUPLOT_SETTINGS="""
set termoption noenhanced
set key outside         # if we have a legend, put it outside the graph
set key at screen 1,1 right horizontal spacing 1
set xlabel 'Timestep' font 'Times,15'
set grid
set style fill solid 0.3		# this number specifies the opacity of the filled in box.
set boxwidth 0.50 relative		# 1.0 is the whisker-boxes touching
set datafile missing '?'	# unknown values are '?'
#set mxtics 5            # make small little tics along the x-axis

### Okay, I know all of this is really verbose, but the are static settings, so I include them here.
set style line 1 linetype 1 linewidth 1.5 pointsize 1.0 # 1st colored meanline/meanpoint
set style line 2 linetype 2 linewidth 1.5 pointsize 1.0 # 2nd colored meanline/meanpoint
set style line 3 linetype 3 linewidth 1.5 pointsize 1.0 # 3rd colored meanline/meanpoint

set style line 501 linetype 1 linewidth 1.5		# 1st colored Whisker
set style line 502 linetype 2 linewidth 1.5		# 2nd colored Whisker
set style line 503 linetype 3 linewidth 1.5 		# 3rd colored Whisker

# set border 15 linetype 501 linewidth 0
# set border 15 linetype 502 linewidth 0
# set border 15 linetype 503 linewidth 0

set style line 51 linetype 1 linewidth 3			# 1st Whisker median
set style line 52 linetype 2 linewidth 3			# 2nd Whisker median
set style line 53 linetype 3 linewidth 3			# 3rd Whisker median

set style line 54 linetype 1 linewidth 1 pointtype 0 		# 1st meanline's stderr 
set style line 55 linetype 2 linewidth 1 pointtype 0 		# 2nd meanline's stderr
set style line 56 linetype 3 linewidth 1 pointtype 0 		# 3rd meanline's stderr

set style line 601 linetype 4 linewidth 1.5			# 1st colored maxline
set style line 602 linetype 5 linewidth 1.5			# 2nd colored maxline
set style line 603 linetype 6 linewidth 1.5			# 3rd colored maxline
set style line 604 linetype 7 linewidth 1 pointsize 1.0		# maxline when there is no legend
set style line 605 linetype 8 linewidth 2 pointsize 2.0		# AVERAGE maxline

set style line 96 linetype 0 linewidth 1			# Whisker when there is no legend
set style line 97 linetype 0 linewidth 3 			# Whisker's median when there is no legend
set style line 98 linetype 0 linewidth 1 pointtype 0		# meanline's STDERR bars when there is no legend
set style line 99 linetype 0 linewidth 1 pointsize 1.0	# meanline/meanpoint when there is no legend

set style line 100 linetype -1 linewidth 3 pointsize 2.0	# AVERAGE meanline/meanpoint
set style line 101 linetype -1 linewidth 1 pointtype 0	# AVERAGE meanline's stderr ars
set style line 103 linetype -1 linewidth 1.5			# AVERAGE Whisker
set style line 102 linetype -1 linewidth 3			# AVERAGE Whisker's median

### END linestyle verbosity
"""

# Default plotting stats
flag_plotWhiskerbars=True
flag_plotSmooth=False
GNUPLOT_SMOOTHING_FUNCTION='csplines' 		# reasonable smoothing options are: csplines, acsplines, bezier, sbezier
inputplotfilename='AvrComplexity.plt'
outputfilenameGNU="/tmp/,plotNeuralComplexity_" + str(os.getpid()) + ".gnuplot"

GNUPLOT_MULTIPLOTSETTINGS="""
set key at screen 1,1 right horizontal spacing 1	# even though this is already set in the regular GNUPLOT settings, you have to do it again here -- you just do.
set bar 0.2             # if we are going to print errorbars, make smaller horizontal knobs on the ends.
set grid noxtics	# turn off the grid on the xtics, it just creates clutter anyway
###
set tmargin 1.0
set bmargin 0.8
set lmargin 6.0
set xtics scale 0.0 offset 0,0.5
#set ytics scale 0.1
set ytics autofreq
#set format y ''
#set format x ''
###
unset xlabel
unset ylabel
set border 10
###
"""

flag_have_previously_plotted_a_file = False
flag_have_previously_plotted_a_max = False
tempfilename='/tmp/,plotNeuralComplexity_%s.plt' % ( os.getpid() )		# this file will contain the raw data
gnufilename='/tmp/,plotNeuralComplexity_%s.gnuplot' % ( os.getpid() )	# this file will contain gnuplot commands
flag_plotPoints 		= False
flag_plotMean 			= False
flag_plotErrorbars		= False
flag_plotLegend			= False
flag_plotWhiskers		= False
flag_plotWhiskers_AVERAGE	= False
flag_plotMean_AVERAGE		= False
flag_plotErrorbars_AVERAGE	= False
flag_plotProcessing		= False
flag_plotInput			= False
flag_plotAll			= False
flag_plotMax			= False
flag_plotMax_AVERAGE		= False
flag_multiplot 			= False
###############
numplotsmade=0
PASSED_DIRECTORY=''
multiplotDimX = 0
multiplotDimY = 0
RUN_DIRS={ 'bestRecent': [], 'Recent': [] }
GNUPLOT_TOPRIGHT_LABEL=[ "Generated `date +%Y-%m-%d` by `whoami`" ]
multiplotmaxtimesteps={} # we only use this if we're multiplotting.  It lets us set the range and xtics for each plot invidually to make them pretty
################################################################################
def print_usage_and_exit():
	print """
USAGE 
       plotNeuralComplexity [-lmep] [-MXxY] -[API] directory

DESCRIPTION
       plotNeuralComplexity plots the Olafcomplexity from one or more Polyworld run/ directories.

OPTIONS
       -l      A legend is to be drawn and different colors are are used the All/Processing/Input lines.  Lines will be labeled
               in the legend using the names of the run directories (after stripping any leading numbers). If not
               -l, all lines will be printed in the same identical gray color. (default off)
       
       -w/W    Box-and-Whiskers plot. 'w' signifies display each run as a whiskers plot. 'W' displays the averages all runs as a whiskers plot. (default off)
               '-W' is only useful if you are plotting over >=5 run/ directories. 

       -n/N    The mean of each param will be computed and drawn as a line. (-n: default on, -N: default off)
               If the timestep interval in 'AvrComplexity.plt' is different across runs, the mean will be computed for the timesteps
               in the first directory.  For example, if the first run/ directory had an interval=1000, but another AvrComplexity.plt
               had interval=500, the mean would only be computed every 1000 timesteps.  This is a feature
               to control the temporal precision of the average line.

       -e/E    Standard Error bars for the mean will be drawn. (default off)

       -x/X    Maximums (the top of the whiskers) will be drawn as a line. (default off)

       -p      Draw the points that make up the '-n' mean line(s). (default off)

       -s      Make a separate plot with the lines smoothed with '%s'. (default off)

       -MXxY   Multiplot putting each run/ directory on it's own graph.  Does not plot -WNE. (default off)

       -A      Plot NeuralComplexity across 'All' neurons. (default off)

       -P      Plot NeuralComplexity across 'Processing' neurons. (default on)

       -I      Plot NeuralComplexity across 'Input' neurons. (default off)

	""" % (GNUPLOT_SMOOTHING_FUNCTION)
	sys.exit(1)
####################################################################################
####################################################################################
####################################################################################
def CONVERT_TO_MULTIPLOT( plotstring ):
	global inputplotfilename, tempfilename

	mp_plotstring = []
#	mp_plotstring.append('set autoscale xfix')
	try:
		for i in range(len(plotstring)):
			if tempfilename in plotstring[i] or plotstring[i] == '':
				plotstring.pop(i)		# remove any lines about the AVERAGE
	except IndexError:
		print "* Error: You didn't specify anything that multiplot can plot!"
		sys.exit(1)

	for i in range(len(plotstring)):
		plotfilename = re.findall("^\'[^\']*%s\'" % (inputplotfilename) ,plotstring[i])[0].strip("'")

		# this little section makes the x-axis pretty
		plotfile = open( plotfilename )
		finaltimestep_of_this_miniplot = plotfile.readlines()[-1].split("\t")[0]
		print "finaltimestep=%s" % ( finaltimestep_of_this_miniplot )
		mp_plotstring.append("set xrange [0:%s]" % (finaltimestep_of_this_miniplot) )
		mp_plotstring.append("set xtics 0,%s,%s" % (finaltimestep_of_this_miniplot, finaltimestep_of_this_miniplot) )
		# end section that makes the x-axis pretty

		minititle = plotfilename.replace("/brain/Recent/" + inputplotfilename,'').replace("/brain/bestRecent/" + inputplotfilename,'')	# strip /brain/bestRecent/AvrComplexity.plt or /brain/Recent/AvrComplexity.plt
		minititle = minititle.split('/')[-1]	# now only get the directory part
		mp_plotstring.append( 'set title "%s" offset 0,-1' % ( minititle ) )

		plotstring[i] = 'plot ' + plotstring[i]
#		print "%s: %s" % (i, plotstring[i])
		mp_plotstring.append( plotstring[i] )

	return '\n'.join( mp_plotstring )
####################################################################################
# In addition to returning the median, get_median() also returns the upper and lower half of the list
# Note that this function ASSUMES THE LIST IS ALREADY SORTED.
####################################################################################
def get_median( listofnumbers ):

        length=len(listofnumbers)
        lenover2=int(length / 2)

	listofnumbers = map( float, listofnumbers )	# convert them all to float
	listofnumbers.sort()				# sort them.

#	print "- length=%s lenover2=%s" % ( length, lenover2)
	
	middle1=listofnumbers[ lenover2 ]                       # this number is the answer if the length is ODD, and half of the answer is the length is EVEN
	lowerhalf=listofnumbers[: lenover2 ]    # first half of the numbers

                
	if length % 2 == 0:                     # if the length of the list is an EVEN number
		upperhalf=listofnumbers[ lenover2 :]
		middle2=listofnumbers[ (lenover2 - 1) ]
		median = (middle1 + middle2) / 2.0
	else:                                           # the length of the list is an ODD number, so simply return the middle number.
		upperhalf=listofnumbers[(lenover2+1) :] # second half of the numbers
		median = middle1
	if lowerhalf == []: lowerhalf = [ median ]
	if upperhalf == []: upperhalf = [ median ]

#	print "nums=%s" % ( listofnumbers )
#	print "median=%s" % ( median )
#	print "lowerhalf=%s" % ( lowerhalf )    
#	print "upperhalf=%s" % ( upperhalf )
        
        return median, lowerhalf, upperhalf
######################################################################################
# GET_GNUPLOT_PLOTSTRING_SMOOTH -- this function calls the function GET_GNUPLOT_PLOTSTRING, and then some manipulations to make the SMOOTHED plotstring
#######################################################################################
def GET_GNUPLOT_PLOTSTRING_SMOOTH( filename, Avrfilename ):
	global GNUPLOT_SMOOTHING_FUNCTION, flag_plotMean, flag_plotMean_AVERAGE, flag_plotMax, flag_plotMax_AVERAGE

	rawarray = GET_GNUPLOT_PLOTSTRING( filename, Avrfilename ).split(', ')

	if flag_plotMean or flag_plotMean_AVERAGE or flag_plotMax or flag_plotMax_AVERAGE:		# only do this if we have lines to begin with!
		for i in range(0, len(rawarray) ):
			# make sure that it's not candlesticks, not yerrorbars, and (is an averageline OR is a meanline) and only using #:#
#			if 'candlesticks' not in rawarray[i] and 'yerrorbars' not in rawarray[i] and ('meta-mean' in rawarray[i] or flag_plotMean) and re.search( 'using [0-9]+:[0-9]+[^:]', rawarray[i] ):
			if 'candlesticks' not in rawarray[i] and 'yerrorbars' not in rawarray[i] and re.search( 'using [0-9]+:[0-9]+[^:]', rawarray[i] ):
#				print "- smoothing: %s" % ( rawarray[i] )
				rawarray[i] = rawarray[i].rstrip(', ')
				rawarray[i] += " smooth %s" % (GNUPLOT_SMOOTHING_FUNCTION )

#	print "rawarray=%s" % (rawarray)

	smoothstring =	', '.join( rawarray )

	return smoothstring

#######################################################################################
def GET_GNUPLOT_DYNAMIC_SETTINGS( RecentOrbestRecent ):
	global flag_plotPoints, flag_plotLegend, flag_multiplot, multiplotDimX, multiplotY
	global RUN_DIRS, PARAMS, IDENTICAL_LINE_WIDTH, GNUPLOT_TOPRIGHT_LABEL, MAXTIMESTEP
	global numplotsmade, GNUPLOT_TERMINAL, flag_plotMean, flag_plotMean_AVERAGE
	global flag_plotAll, flag_plotProcessing, flag_plotInput
	settings = [ ]

	
	settings.append("set terminal %s %s" % ( GNUPLOT_TERMINAL, numplotsmade ) )
	numplotsmade += 1


	if not flag_multiplot: settings.append( 'set title "%s -- %s"' % (PASSED_DIRECTORY, RecentOrbestRecent) )	# set the title

	# Define our ylabel
	ylabel = "NeuralComplexity: "
	if flag_plotAll: ylabel += 'All, '
	if flag_plotProcessing: ylabel += 'Processing, '
	if flag_plotInput: ylabel += 'Input, '
	settings.append("set ylabel '%s' font 'Times,15'" % (ylabel.rstrip(', ')) )	# take off the trailing coma and space before using.
	# done defining the ylabel

	if not flag_plotLegend:
		settings.append("unset key")					# if no legend, unset the legend

	if not flag_multiplot:
		settings.append( "set xrange [0:%s]" % (MAXTIMESTEP) )

	# We are plotting the mean as a line, point, or both?
	if flag_plotPoints and (flag_plotMean or flag_plotMax):
		settings.append("set style data linespoints")
	elif flag_plotMean or flag_plotMax:
		settings.append("set pointsize 0.0")		# set pointsize isn't yet supported by AquaTerm but it probably will someday
		settings.append("set style data lines")
	elif flag_plotPoints:
		settings.append("set style data points")

	# make the TopRight Label
        settings.append( 'set label "%s" at screen 0.001,0.98 left' % ('\\n'.join(GNUPLOT_TOPRIGHT_LABEL)) )

	if flag_multiplot:
		settings.append( "set multiplot layout %s, %s title '%s/ -- %s'" % ( multiplotDimY, multiplotDimX, PASSED_DIRECTORY, RecentOrbestRecent ) ) 
		settings.append( GNUPLOT_MULTIPLOTSETTINGS )	# put in the multiplot settings on top of the regular settings

	return '\n'.join(settings)
#####################################
# This function specifies the stuff to include at the end of the very end of the plot.
def GET_GNUPLOT_END_SETTINGS():
	global flag_multiplot
	z = []
		
	if flag_multiplot: z.append( "unset multiplot" )
	z.append( "raise" )			# this causes the most recent plot come to the front of the desktop.

	return '\n'.join(z)
	# END
#####################################

def GET_GNUPLOT_PLOTSTRING( filename, Avrfilename ):
	global RUN_DIRS, flag_plotLegend, flag_plotWhiskers, flag_plotMean, flag_plotErrorbars, flag_plotSmooth, flag_plotWhiskers_AVERAGE, flag_plotMean_AVERAGE, flag_plotErrorbars_AVERAGE, flag_plotAll, flag_plotProcessing, flag_plotInput, flag_have_previously_plotted_a_file, flag_have_previously_plotted_a_max
	global  flag_plotMax, flag_plotMax_AVERAGE	

	plotstring = [ ]
	
	if filename:
		if flag_plotWhiskers:	# are we doing the whiskers for each one?
			if flag_have_previously_plotted_a_file:
				Atitle, Ptitle, Ititle = ('','','')
			else:
				flag_have_previously_plotted_a_file = True
				Atitle,Ptitle,Ititle=('All','Processing','Input')

			if flag_plotLegend: temp = [ 501, 51, 502, 52, 503, 53 ]
			else:	temp = [ 96, 97, 96, 97, 96, 97 ]

			if flag_plotAll:	# and we're plotting the inputs...
				plotstring.append("'%s' using 1:3:2:6:5 with candlesticks whiskerbars linestyle %s title '%s', '' using 1:4:4:4:4 with candlesticks linestyle %s notitle" % (filename, temp[0], Atitle, temp[1] ))
				temp.pop(0)
				temp.pop(0)

			if flag_plotProcessing:	
				plotstring.append("'%s' using 1:11:10:14:13 with candlesticks whiskerbars linestyle %s title '%s', '' using 1:12:12:12:12 with candlesticks linestyle %s notitle" % (filename, temp[0], Ptitle, temp[1] ))
				temp.pop(0)
				temp.pop(0)

			if flag_plotInput:	
				plotstring.append("'%s' using 1:19:18:22:21 with candlesticks whiskerbars linestyle %s title '%s', '' using 1:20:20:20:20 with candlesticks linestyle %s notitle" % (filename, temp[0], Ititle, temp[1] ))
				temp.pop(0)
				temp.pop(0)

		if flag_plotMean or flag_plotPoints:
			if flag_have_previously_plotted_a_file:
				Atitle, Ptitle, Ititle = ('','','')
			else:			
				flag_have_previously_plotted_a_file = True
				Atitle,Ptitle,Ititle=('mean All','mean Processing','mean Input')

			if flag_plotLegend: 
				if flag_plotErrorbars: temp = [ 1, 54, 2, 55, 3, 56 ]
				else: temp = [ 1, 2, 3 ]
			else:
				if flag_plotErrorbars: temp = [ 99, 98, 99, 98, 99, 98 ]
				else: temp = [ 99, 99, 99 ]

			if flag_plotAll:
				plotstring.append("'%s' using 1:7 linestyle %s title '%s'" % (filename, temp[0], Atitle) )
				temp.pop(0)
				if flag_plotErrorbars: 
					plotstring.append("'' using 1:7:8 with yerrorbars linestyle %s notitle" % (temp[0]))
					temp.pop(0)
			if flag_plotProcessing:
				plotstring.append("'%s' using 1:15 linestyle %s title '%s'" % (filename, temp[0], Ptitle) )
				temp.pop(0)
				if flag_plotErrorbars: 
					plotstring.append("'' using 1:15:16 with yerrorbars linestyle %s notitle" % (temp[0]))
					temp.pop(0)

			if flag_plotInput:
				plotstring.append("'%s' using 1:23 linestyle %s title '%s'" % (filename, temp[0], Ititle) )
				temp.pop(0)
				if flag_plotErrorbars: 
					plotstring.append("'' using 1:23:24 with yerrorbars linestyle %s notitle" % (temp[0]))
					temp.pop(0)


                if flag_plotMax:   # are we doing the MAX for each one?
                        if flag_have_previously_plotted_a_max:
                                Atitle, Ptitle, Ititle = ('','','')
                        else:
                                flag_have_previously_plotted_a_max = True
                                Atitle,Ptitle,Ititle=('maxAll','maxProcessing','maxInput')

                        if flag_plotLegend: temp = [ 601, 602, 603 ]
                        else:   temp = [ 604, 604, 604 ]


			if flag_plotAll:
				plotstring.append("'%s' using 1:6 linestyle %s title '%s'" % (filename, temp[0], Atitle) )
				temp.pop(0)
			if flag_plotProcessing:
				plotstring.append("'%s' using 1:14 linestyle %s title '%s'" % (filename, temp[0], Ptitle) )
				temp.pop(0)
			if flag_plotInput:
				plotstring.append("'%s' using 1:22 linestyle %s title '%s'" % (filename, temp[0], Ititle) )
				temp.pop(0)


	if Avrfilename:	
		##### NOW FOR THE AVERAGES ###########
		if flag_plotWhiskers_AVERAGE:	# are we doing the whiskers for the AVERAGE?

			temp = [ 103, 102, 103, 102, 103, 102 ]
	
			if flag_plotAll:	# and we're plotting the inputs...
				plotstring.append("'%s' using 1:3:2:6:5 with candlesticks whiskerbars linestyle %s title 'All means', '' using 1:4:4:4:4 with candlesticks linestyle %s notitle" % (Avrfilename, temp[0], temp[1] ))
				temp.pop(0)
				temp.pop(0)
	
			if flag_plotProcessing:	
				plotstring.append("'%s' using 1:11:10:14:13 with candlesticks whiskerbars linestyle %s title 'Processing means', '' using 1:12:12:12:12 with candlesticks linestyle %s notitle" % (Avrfilename, temp[0], temp[1] ))
				temp.pop(0)
				temp.pop(0)
	
			if flag_plotInput:	
				plotstring.append("'%s' using 1:19:18:22:21 with candlesticks whiskerbars linestyle %s title 'Input means', '' using 1:20:20:20:20 with candlesticks linestyle %s notitle" % (Avrfilename, temp[0], temp[1] ))
				temp.pop(0)
				temp.pop(0)
	
		if flag_plotMean_AVERAGE:
                        if flag_plotWhiskers_AVERAGE:   # if we plotted Whiskers, dont makes keys for the averages
				Atitle, Ptitle, Ititle = ('', '', '')
			else:
				Atitle, Ptitle, Ititle = ('meta-mean All', 'meta-mean Pro', 'meta-mean Inp')
			if flag_plotErrorbars_AVERAGE: temp = [ 100, 101, 100, 101, 100, 101 ]
			else: temp = [ 100, 100, 100 ]
	
			if flag_plotAll:
				plotstring.append("'%s' using 1:7 with lines linestyle %s title '%s'" % (Avrfilename, temp[0], Atitle) )
				temp.pop(0)
				if flag_plotErrorbars_AVERAGE: 
					plotstring.append("'' using 1:7:8 with yerrorbars linestyle %s notitle" % (temp[0]))
					temp.pop(0)
			if flag_plotProcessing:
				plotstring.append("'%s' using 1:15 with lines linestyle %s title '%s'" % (Avrfilename, temp[0], Ptitle) )
				temp.pop(0)
				if flag_plotErrorbars_AVERAGE: 
					plotstring.append("'' using 1:15:16 with yerrorbars linestyle %s notitle" % (temp[0]))
					temp.pop(0)
			if flag_plotInput:
				plotstring.append("'%s' using 1:23 with lines linestyle %s title '%s'" % (Avrfilename, temp[0], Ititle) )
				temp.pop(0)
				if flag_plotErrorbars_AVERAGE: 
					plotstring.append("'' using 1:23:24 with yerrorbars linestyle %s notitle" % (temp[0]))
					temp.pop(0)

                if flag_plotMax_AVERAGE:   # are we doing the MAX for each one?
			Atitle,Ptitle,Ititle=('max-mmAll','max-mmProcessing','max-mmInput')

                        temp = [ 605, 605, 605 ]

			if flag_plotAll:
				plotstring.append("'%s' using 1:6 linestyle %s title '%s'" % (Avrfilename, temp[0], Atitle) )
				temp.pop(0)
			if flag_plotProcessing:
				plotstring.append("'%s' using 1:14 linestyle %s title '%s'" % (Avrfilename, temp[0], Ptitle) )
				temp.pop(0)
			if flag_plotInput:
				plotstring.append("'%s' using 1:22 linestyle %s title '%s'" % (Avrfilename, temp[0], Ititle) )
				temp.pop(0)
	
	plotstring = ', '.join(plotstring)
	return plotstring
	
"""
	# Okay, we've made our regular plostring, but now we're going to completely transform it if we're multiplotting...
	if flag_multiplot:
		global multiplotmaxtimesteps
		mplotstrings=[]
		mplotstringssmooth=[]
		for i in range(0, len(RUN_DIRS)):
			# set the title for each miniplot
			miniplottitle=(RUN_DIRS[i].split('/')[-1]).replace('_','_')
			mplotstrings.append( 'set title "%s" offset 0,-1' % (miniplottitle) )			
			mplotstringssmooth.append( 'set title "%s" offset 0,-1' % (miniplottitle) )

			# set the xrange and xtics for each miniplot
			mplotstrings.append( 'set xrange[0:%s]' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )	
			mplotstrings.append( 'set xtics 0, %s' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )
			mplotstringssmooth.append( 'set xrange[0:%s]' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )
			mplotstringssmooth.append( 'set xtics 0, %s' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )

			# make the plotstrings
			mplotstrings.append( 'plot ' + ', '.join( plotstring[i:num_rundir_lines:len(RUN_DIRS)] ) )
			mplotstringssmooth.append( 'plot ' + ', '.join( plotstringsmooth[i:num_rundir_lines:len(RUN_DIRS)] ) )
""" # END
""" # BEGIN			
			# fix the linestyles within the plotstring we just made
			regularlinestyles=re.findall("linestyle [0-9]*", mplotstrings[-1])
			currentstyle=1
			for regularlinestyle in regularlinestyles:
				mplotstrings[-1] = mplotstrings[-1].replace( regularlinestyle, 'linestyle %s' % (currentstyle) )
				mplotstringssmooth[-1] = mplotstringssmooth[-1].replace( regularlinestyle, 'linestyle %s' % (currentstyle) )
				currentstyle += 1
		
		# and join it all into one lovely string separated by newlines
		plotstring = '\n'.join( mplotstrings )
		plotstringsmooth= '\n'.join( mplotstringssmooth )
		# now do a string replace for each PARAM to make the Legends not have the run/ directory in them.
		for param in PARAMS:
			plotstring = re.sub("title '%s[^']*'" % (param), "title '%s'" % (param), plotstring )
			plotstringsmooth = re.sub("title '%s[^']*'" % (param), "title '%s'" % (param), plotstringsmooth )

	else:			# if multiplot is NOT turned on, just join the strings.
		plotstring='plot ' + ', '.join( plotstring )			 # begin with 'plot' and join each line to be plotted with a coma.
		plotstringsmooth='plot ' + ', '.join( plotstringsmooth)		 # begin with 'plot' and join each line to be plotted with a coma.

""" # END
######################################

def sample_mean( list ):
	N = len(list)
	mean = sum(list) / N

	SSE=0
	for item in list: SSE += (item - mean)**2.0

	try: variance = SSE / (N-1)
	except: variance = 0

	stderr = ( variance ** 0.5 ) / (N**0.5)	# stderr = stddev / sqrt(N)
	return mean, stderr

def check_parameters( argv ):
	try: opts, args = getopt.getopt( argv, "esnwENWlpAPIxXM:")
	except getopt.GetoptError: print_usage_and_exit() 

#	print "opts=%s" % ( opts )
#	print "args=%s" % ( args)

	global flag_plotLegend, flag_plotErrorbars, flag_multiplot, flag_plotMean, flag_plotPoints, PASSED_DIRECTORY, multiplotDimX, multiplotDimY	# grant access to the global variables we're going to modify
	global flag_plotErrorbars_AVERAGE, flag_plotMean_AVERAGE, flag_plotWhiskers, flag_plotWhiskers_AVERAGE
	global flag_plotAll, flag_plotProcessing, flag_plotInput, flag_plotSmooth
	global flag_plotMax, flag_plotMax_AVERAGE
	# Set our plot flags
	for opt in opts:

		if   '-e' in opt:
			flag_plotErrorbars = True
		elif '-s' in opt:
			flag_plotSmooth = True
		elif '-n' in opt:
			flag_plotMean = True
		elif '-w' in opt:
			flag_plotWhiskers = True
		elif '-E' in opt:
			flag_plotErrorbars_AVERAGE = True
		elif '-N' in opt:
			flag_plotMean_AVERAGE = True
		elif '-W' in opt:
			flag_plotWhiskers_AVERAGE = True
		elif '-l' in opt:
			flag_plotLegend = True
		elif '-x' in opt:
			flag_plotMax = True
		elif '-X' in opt:
			flag_plotMax_AVERAGE = True
		elif '-p' in opt:
			flag_plotPoints = True
		elif '-A' in opt:
			flag_plotAll = True
		elif '-P' in opt:
			flag_plotProcessing = True
		elif '-I' in opt:
			flag_plotInput = True
		elif '-M' in opt:
			flag_multiplot = True
			try: multiplotDimX, multiplotDimY = map(int, (opt[1]).split('x'))
			except ValueError: print_usage_and_exit()
		else:
			print "* Error: Do not know argument '%s'" % (opt)
			print_usage_and_exit()

	# Some default settings if the user doesn't specify anything...
	if not flag_plotInput and not flag_plotAll: flag_plotProcessing = True	# if no -[API] is specified, assume -P.

	if not flag_plotWhiskers and not flag_plotMax and not flag_plotWhiskers_AVERAGE and not flag_plotMean_AVERAGE and not flag_plotPoints:
		flag_plotMean = True						# if nothing to plot is specified, plot the meanlines.

	# If we don't have a single argument, exit.
	if len(args) != 1: print_usage_and_exit()
	
	PASSED_DIRECTORY = args[0].rstrip( '/' )	# removing any trailing slash

############################### Finished the parsing of the input parameters, now to look at the RUN_DIRS

	global RUN_DIRS

	if not os.path.isdir( PASSED_DIRECTORY ):			# if the passed directory wasn't a directory, exit.
		print "* Error: '%s' isn't a directory." % ( PASSED_DIRECTORY )
		print_usage_and_exit()

	for whichrecent in RUN_DIRS:
		if os.path.isfile( PASSED_DIRECTORY + '/brain/'+ whichrecent + '/' + inputplotfilename ): 	# if 'directory' is itself a run/ directory, just use that.
			RUN_DIRS[whichrecent].append( PASSED_DIRECTORY )

		else:						# 'directory' is a directory, but is NOT a run/ directory itself.  Is it a list of run directories?
			for potential_rundir in os.listdir( PASSED_DIRECTORY ):
				if os.path.isfile( PASSED_DIRECTORY + '/' + potential_rundir + '/brain/' + whichrecent + '/' + inputplotfilename ):
					RUN_DIRS[whichrecent].append( PASSED_DIRECTORY + '/' + potential_rundir )	# if potential_directory is a run/ directory, add it.

		if flag_multiplot and len(RUN_DIRS[whichrecent]) > multiplotDimX * multiplotDimY:		# if multiplot is turned on only go up to dimX*dimY
			print "* Warning: There are %s run/ directories in %s, but multiplot can only plot %s plots -- only using the first %s." % ( len(RUN_DIRS[whichrecent]), PASSED_DIRECTORY, multiplotDimX * multiplotDimY, multiplotDimX * multiplotDimY )
			RUN_DIRS[whichrecent] = RUN_DIRS[whichrecent][: (multiplotDimX * multiplotDimY)]

		print "RUN_DIRS[%s]=%s" % ( whichrecent, RUN_DIRS[whichrecent] )

	if not RUN_DIRS['bestRecent'] and not RUN_DIRS['Recent']:
		print "* Error: There were no Polyworld run/ directories in %s." % ( PASSED_DIRECTORY )
		sys.exit(1)

##################################################################################
#This function gets the bestRecentBrainFunctionRecordFrequency as specified in the worldfile for a given run/ directory.
##################################################################################
def get_bestRecentBrainFunctionRecordFrequency( run_dir ):
	bestRecentBrainFunctionRecordFrequency=-1

	try:
		worldfile = open( run_dir + '/worldfile' )
		for line in worldfile:
			if 'bestRecentBrainFunctionRecordFrequency' in line:
				bestRecentBrainFunctionRecordFrequency = int( re.match('([0-9]*)', line).groups(0)[0] )	
		worldfile.close()
	except:
		print "* Error: Could not open '%s/worldfile'. Exiting." % ( run_dir )
		sys.exit(1)

	if bestRecentBrainFunctionRecordFrequency == -1:
		print "* Error: Couldn't find a value for 'bestRecentBrainFunctionRecordFrequency' in %s/worldfile.  Exiting." % (run_dir)
		sys.exit(1)
		
	return bestRecentBrainFunctionRecordFrequency
########################################################################################################################		
########################################################################################################################		
########################################################################################################################		
### Real program begins here

check_parameters( sys.argv[1:] )		# don't send it the first item in the sys.argv list because that's this programs filename
#print "- plotPoints=%s plotMean=%s plotErrorbars=%s plotWhiskers=%s plotLegend=%s" % ( flag_plotPoints, flag_plotMean, flag_plotErrorbars, flag_plotWhiskers, flag_plotLegend )
#print "- plotMeanAverage=%s plotErrorbarsAverage=%s plotWhiskersAverage=%s" % ( flag_plotMean_AVERAGE, flag_plotErrorbars_AVERAGE, flag_plotWhiskers_AVERAGE )
#print "- plotAll=%s plotProcessing=%s plotInput=%s" % ( flag_plotAll, flag_plotProcessing, flag_plotInput )

if len(RUN_DIRS['bestRecent']): averagetimestepinterval = get_bestRecentBrainFunctionRecordFrequency( RUN_DIRS['bestRecent'][0]  )
elif len(RUN_DIRS['Recent']): averagetimestepinterval = get_bestRecentBrainFunctionRecordFrequency( RUN_DIRS['Recent'][0]  )
else:
	print "* Error: Everything is empty!"
	sys.exit(1)

print "- AverageInterval=%s" % (averagetimestepinterval),


DATA = { 'bestRecent': {}, 'Recent': {} }	# make a dictionary of dictionaries
MAXTIMESTEP=0
for whichrecent in RUN_DIRS:
	for rundir in RUN_DIRS[whichrecent]:
		filename = rundir + '/brain/' + whichrecent + '/' + inputplotfilename
		inputplotfile = open( filename )
		for line in inputplotfile:
			if line.startswith('#'):	# if the line is a comment (begins with #)
				continue;
			line_array=line.split('\t')
			if len( line_array ) < 24:
				print "* Error: Did not find enough columns in file '%s'.  Only found %s columns." % ( filename, len(line_array) )
				sys.exit(1)

			t = int(line_array[0])
			if t not in DATA[whichrecent]:
				DATA[whichrecent][t] = {}
				DATA[whichrecent][t]['Pro']=[]
				DATA[whichrecent][t]['All']=[]
				DATA[whichrecent][t]['Inp']=[]

			DATA[whichrecent][t]['All'].append( line_array[6 ] ) 
			DATA[whichrecent][t]['Pro'].append( line_array[14] )
			DATA[whichrecent][t]['Inp'].append( line_array[22] )
			if t > MAXTIMESTEP: MAXTIMESTEP = t
#			print "linearray=%s" % (line_array ) 

for whichrecent in RUN_DIRS.keys():				# if we have no entries in this Recent/bestRecent, delete it.
	if len( DATA[whichrecent] ) == 0:
		del RUN_DIRS[whichrecent]

# Open the file that we're going to store the data on the averages.
#for whichrecent in ('bestRecent','Recent'):
for whichrecent in RUN_DIRS:

	tempfile=open( tempfilename + '.' + whichrecent, 'w' )
	print "tempfilename=%s" % ( tempfilename + '.' + whichrecent ),
	for t in [0] + range(averagetimestepinterval,MAXTIMESTEP+averagetimestepinterval,averagetimestepinterval):
		list_to_print = [ t ]
		for area in ('All','Pro','Inp'):
			DATA[whichrecent][t][area] = map( float, DATA[whichrecent][t][area] )	# make sure they are all floats so we comparing correctly.
			minimum=min( DATA[whichrecent][t][area] )
			maximum=max( DATA[whichrecent][t][area] )
			median, lowerhalf, upperhalf = get_median( DATA[whichrecent][t][area] )
			q1=get_median( lowerhalf )[0]
			q3=get_median( upperhalf )[0]
			mean, mean_stderr = sample_mean( DATA[ whichrecent ][t][area] )
			if DATA[whichrecent][t][area] == ['']: numsamples=0
			else: numsamples=len(DATA[whichrecent][t][area])

			list_to_print.append( "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" % ( minimum, q1, median, q3, maximum, mean, mean_stderr, numsamples ) )
#			del DATA[whichrecent][t][area]		# Don't need this anymore
		list_to_print = map(str, list_to_print)
		tempfile.write( '\t'.join( list_to_print ) )
		tempfile.write('\n')
		tempfile.flush()
	tempfile.close()

print "- maxtimestep=%s" % ( MAXTIMESTEP )

# Okay, now we've finished creating our data for the meta-means, now lets make our .gnuplot file
	
outputcontents = [ GNUPLOT_SETTINGS ]	# begin our .gnuplot file with the static settings.

for whichrecent in RUN_DIRS:
	flag_have_previously_plotted_a_file, flag_have_previously_plotted_a_max = (False, False)
	outputcontents.append( GET_GNUPLOT_DYNAMIC_SETTINGS( whichrecent ) )	# Make a different plot for Recent/bestRecent
	plotstring = []

	for rundir in RUN_DIRS[whichrecent]:
		filename = rundir + '/brain/' + whichrecent + '/' + inputplotfilename
		plotstring.append( GET_GNUPLOT_PLOTSTRING(filename, '') )

	if flag_plotWhiskers_AVERAGE or flag_plotMean_AVERAGE or flag_plotErrorbars_AVERAGE or flag_plotMax_AVERAGE:
		Avrfilename =  tempfilename + '.' + whichrecent
		plotstring.append( GET_GNUPLOT_PLOTSTRING('', Avrfilename) )		# plot the Averages last because they are important and we want them to be laid on top of the graph

        for dummycounter in range( plotstring.count('') ): plotstring.remove('')        # remove all blank entries from the plotstring.  They shouldnt have cropped in, but lets be sure.

	if flag_multiplot:
		multiplot_plotstring = CONVERT_TO_MULTIPLOT( plotstring )
		outputcontents.append( multiplot_plotstring )
	else:
		outputcontents.append( 'plot ' + ', '.join(plotstring) )

	outputcontents.append( GET_GNUPLOT_END_SETTINGS() )


if flag_plotSmooth:	# We've finished all of the regular plots, now to do the smoothed plots (if we're doing that)
	outputcontents.append("reset")	# clear everything
	outputcontents.append( GNUPLOT_SETTINGS )	# load the old settings back
        GNUPLOT_TOPRIGHT_LABEL.append( "Smoothed with '%s'" % (GNUPLOT_SMOOTHING_FUNCTION) )

	for whichrecent in RUN_DIRS:
		flag_have_previously_plotted_a_file, flag_have_previously_plotted_a_max = (False, False)
		outputcontents.append( GET_GNUPLOT_DYNAMIC_SETTINGS( whichrecent ) )
		plotstring = []

		for rundir in RUN_DIRS[whichrecent]:
			filename = rundir + '/brain/' + whichrecent + '/' + inputplotfilename
			plotstring.append( GET_GNUPLOT_PLOTSTRING_SMOOTH(filename, '') )


        if flag_plotWhiskers_AVERAGE or flag_plotMean_AVERAGE or flag_plotErrorbars_AVERAGE or flag_plotMax_AVERAGE:
                Avrfilename =  tempfilename + '.' + whichrecent
                plotstring.append( GET_GNUPLOT_PLOTSTRING('', Avrfilename) )            # plot the Averages last because they are important and we want them to be laid on top of the graph

        for dummycounter in range( plotstring.count('') ): plotstring.remove('')        # remove all blank entries from the plotstring.  They shouldnt have cropped in, but lets be sure.

        if flag_multiplot:
                multiplot_plotstring = CONVERT_TO_MULTIPLOT( plotstring )
                outputcontents.append( multiplot_plotstring )
        else:
                outputcontents.append( 'plot ' + ', '.join(plotstring) )

        outputcontents.append( GET_GNUPLOT_END_SETTINGS() )


outputfileGNU=open( outputfilenameGNU, 'w' )
outputfileGNU.write( '\n'.join(outputcontents) )
outputfileGNU.close()
print "- Executing '%s'" % ( outputfilenameGNU )
os.system( 'gnuplot '+ outputfilenameGNU )

print "Done!"
