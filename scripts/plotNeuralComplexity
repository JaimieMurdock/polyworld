#!/usr/bin/python
################################################################################
# CONFIGURABLE PARAMETERS
################################################################################
# you can edit these as well, but you probably don't want to
# DO NOT EDIT ANYTHING BENEATH HERE UNLESS YOU KNOW WHAT YOU'RE DOING
################################################################################
# Load our Libraries
import sys, getopt, os.path, re, os
# Finished loading libraries
################################################################################
# some global variables:
GNUPLOT_SETTINGS="""
set termoption noenhanced
set key outside         # if we have a legend, put it outside the graph
set key at screen 1,1 right horizontal spacing 1
set xlabel 'Timestep' font 'Times,15'
set ylabel 'Neural Complexity' font 'Times,15'
set grid
set style fill solid 0.25		# this number specifies the opacity of the filled in box.
set boxwidth 0.6 relative		# 1.0 is the whisker-boxes touching
set datafile missing '?'	# unknown values are '?'
#set mxtics 5            # make small little tics along the x-axis

### Okay, I know all of this is really verbose, but the are static settings, so I include them here.
set style line 1 linetype 1 linewidth 1 pointsize 1.0 # 1st colored meanline/meanpoint
set style line 2 linetype 2 linewidth 1 pointsize 1.0 # 2nd colored meanline/meanpoint
set style line 3 linetype 3 linewidth 1 pointsize 1.0 # 3rd colored meanline/meanpoint

set style line 501 linetype 1 linewidth 1 			# 1st colored Whisker
set style line 502 linetype 2 linewidth 1 			# 2nd colored Whisker
set style line 503 linetype 3 linewidth 1 			# 3rd colored Whisker

set style line 51 linetype 1 linewidth 3			# 1st Whisker median
set style line 52 linetype 2 linewidth 3			# 2nd Whisker median
set style line 53 linetype 3 linewidth 3			# 3rd Whisker median

set style line 54 linetype 1 linewidth 1 pointtype 0 		# 1st meanline's stderr 
set style line 55 linetype 2 linewidth 1 pointtype 0 		# 2nd meanline's stderr
set style line 56 linetype 3 linewidth 1 pointtype 0 		# 3rd meanline's stderr

set style line 96 lc rgb "gray" linewidth 1			# Whisker when there is no legend
set style line 97 lc rgb "gray" linewidth 3 			# Whisker's median when there is no legend
set style line 98 lc rgb "gray" linewidth 1 pointtype 0		# meanline's STDERR bars when there is no legend
set style line 99 lc rgb "gray" linewidth 1 pointsize 1.0	# meanline/meanpoint when there is no legend

set style line 100 lc rgb "black" linewidth 3 pointsize 2.0	# AVERAGE meanline/meanpoint
set style line 101 lc rgb "black" linewidth 1 pointtype 0	# AVERAGE meanline's stderr ars
set style line 103 lc rgb "black" linewidth 1.5			# AVERAGE Whisker
set style line 102 lc rgb "black" linewidth 3			# AVERAGE Whisker's median

### END linestyle verbosity
"""

# Default plotting stats
flag_plotWhiskerbars=True
flag_plotSmooth=True
GNUPLOT_SMOOTHING_FUNCTION='csplines' 		# reasonable smoothing options are: csplines, acsplines, bezier, sbezier
inputplotfilename='AvrComplexity.plt'
outputfilenameGNU="/tmp/,plotNeuralComplexity_" + str(os.getpid()) + ".gnuplot"

width_of_meanlines=2

GNUPLOT_MULTIPLOTSETTINGS="""
set key at screen 1,1 right horizontal spacing 1	# even though this is already set in the regular GNUPLOT settings, you have to do it again here -- you just do.
set bar 0.2             # if we are going to print errorbars, make smaller horizontal knobs on the ends.
#set mxtics 5            # make small little tics along the x-axis
set grid noxtics	# turn off the grid on the xtics, it just creates clutter anyway
###
set tmargin 1.5
#set format y ''
#set format x ''
set xtics scale 0.0				# no xtics, they get in the way
###
unset xlabel
unset ylabel
set border 10
###
"""
COLORED_LINE_WIDTH=1.5
IDENTICAL_LINE_WIDTH=0.8
##################
tempfilename='/tmp/,plotNeuralComplexity_%s.plt' % ( os.getpid() )		# this file will contain the raw data
gnufilename='/tmp/,plotNeuralComplexity_%s.gnuplot' % ( os.getpid() )	# this file will contain gnuplot commands
flag_plotPoints 		= False
flag_plotMean 			= False
flag_plotErrorbars		= False
flag_plotLegend			= False
flag_plotWhiskers		= False
flag_plotWhiskers_AVERAGE	= False
flag_plotMean_AVERAGE		= False
flag_plotErrorbars_AVERAGE	= False
flag_plotProcessing=False
flag_plotInput=False
flag_plotAll=False
flag_multiplot 			= False
###############
numplotsmade=0
PASSED_DIRECTORY=''
multiplotDimX = 0
multiplotDimY = 0
RUN_DIRS={ 'bestRecent': [], 'Recent': [] }
GNUPLOT_TOPRIGHT_LABEL=[ "Generated `date +%Y-%m-%d` by `whoami`" ]
multiplotmaxtimesteps={} # we only use this if we're multiplotting.  It lets us set the range and xtics for each plot invidually to make them pretty
################################################################################
def print_usage_and_exit():
	print """
USAGE 
       plotNeuralComplexity [-lmep] [-MXxY] -[API] directory

DESCRIPTION
       plotNeuralComplexity plots the Olafcomplexity from one or more Polyworld run/ directories.

OPTIONS
       -l      A legend is to be drawn and different colors are are used the All/Processing/Input lines.  Lines will be labeled
               in the legend using the names of the run directories (after stripping any leading numbers). If not
               -l, all lines will be printed in the same identical gray color. (default off)
       
       -w/W    Box-and-Whiskers plot. 'w' signifies display each run as a whiskers plot. 'W' displays the averages all runs as a whiskers plot. (default off)

       -n/N    The mean of each param will be computed and drawn as a line. (-n: default on, -N: default off)
               If the timestep interval in 'AvrComplexity.plt' is different across runs, the mean will be computed for the timesteps
               in the first directory.  For example, if the first run/ directory had an interval=1000, but another AvrComplexity.plt
               had interval=500, the mean would only be computed every 1000 timesteps.  This is a feature
               to control the temporal precision of the average line.

       -e/E    Standard Error bars for the mean will be drawn. (default off)

       -p      Draw the 'meanpoints' (default off)

       -MXxY   Multiplot putting each run/ directory on it's own graph.  (default off)

       -A      Plot NeuralComplexity across 'All' neurons. (default off)

       -P      Plot NeuralComplexity across 'Processing' neurons. (default on)

       -I      Plot NeuralComplexity across 'Input' neurons. (default off)

	"""
	sys.exit(1)

####################################
####################################################################################
# In addition to returning the median, get_median() also returns the upper and lower half of the list
# Note that this function ASSUMES THE LIST IS ALREADY SORTED.
####################################################################################
def get_median( listofnumbers ):

        length=len(listofnumbers)
        lenover2=int(length / 2)

#	print "- length=%s lenover2=%s" % ( length, lenover2)
	
	middle1=listofnumbers[ lenover2 ]                       # this number is the answer if the length is ODD, and half of the answer is the length is EVEN
	lowerhalf=listofnumbers[: lenover2 ]    # first half of the numbers

                
	if length % 2 == 0:                     # if the length of the list is an EVEN number
		upperhalf=listofnumbers[ lenover2 :]
		middle2=listofnumbers[ (lenover2 - 1) ]
		median = (middle1 + middle2) / 2.0
	else:                                           # the length of the list is an ODD number, so simply return the middle number.
		upperhalf=listofnumbers[(lenover2+1) :] # second half of the numbers
		median = middle1
	if lowerhalf == []: lowerhalf = [ median ]
	if upperhalf == []: upperhalf = [ median ]

#	print "nums=%s" % ( listofnumbers )
#	print "median=%s" % ( median )
#	print "lowerhalf=%s" % ( lowerhalf )    
#	print "upperhalf=%s" % ( upperhalf )
        
        return median, lowerhalf, upperhalf
#######################################################################################
def GET_GNUPLOT_DYNAMIC_SETTINGS( RecentOrbestRecent ):
	global flag_plotPoints, flag_plotLegend, flag_multiplot, multiplotDimX, multiplotY
	global RUN_DIRS, PARAMS, IDENTICAL_LINE_WIDTH, GNUPLOT_TOPRIGHT_LABEL
	global numplotsmade
	settings = [ ]

	
	settings.append("set terminal aqua %s" % ( numplotsmade ) )
	numplotsmade += 1


	settings.append( 'set title "%s -- %s"' % (PASSED_DIRECTORY, RecentOrbestRecent) )	# set the title

	if not flag_plotLegend:
		settings.append("unset key")					# if no legend, unset the legend

	# We are plotting the mean as a line, point, or both?
	if flag_plotPoints and flag_plotMean:
		settings.append("set style data linespoints")
	elif flag_plotMean:
		settings.append("set pointsize 0.0")		# set pointsize isn't yet supported by AquaTerm but it probably will someday
		settings.append("set style data lines")
	elif flag_plotPoints:
		settings.append("set style data points")

	# make the TopRight Label
        settings.append( 'set label "%s" at screen 0.001,0.98 left' % ('\\n'.join(GNUPLOT_TOPRIGHT_LABEL)) )

	if flag_multiplot:
		settings.append( "set multiplot layout %s, %s title '%s'" % ( multiplotDimY, multiplotDimX, PASSED_DIRECTORY ) ) 
		settings.append( GNUPLOT_MULTIPLOTSETTINGS )	# put in the multiplot settings on top of the regular settings

	return '\n'.join(settings)
#####################################
# This function specifies the stuff to include at the end of the very end of the plot.
def GET_GNUPLOT_END_SETTINGS():
	global flag_multiplot
	z = []
		
	if flag_multiplot: z.append( "unset multiplot" )
	z.append( "raise" )			# this causes the most recent plot come to the front of the desktop.

	return '\n'.join(z)
	# END
#####################################

def GET_GNUPLOT_PLOTSTRING( filename, Avrfilename ):
	global RUN_DIRS, flag_plotLegend, flag_plotWhiskers, flag_plotMean, flag_plotErrorbars, flag_plotSmooth, flag_plotWhiskers_AVERAGE, flag_plotMean_AVERAGE, flag_plotErrorbars_AVERAGE, flag_plotAll, flag_plotProcessing, flag_plotInput


	plotstring = [ ]
	plotstringsmooth=[ ]
	
	if flag_plotWhiskers:	# are we doing the whiskers for each one?
		if flag_plotLegend: temp = [ 501, 51, 502, 52, 503, 53 ]
		else:	temp = [ 96, 97, 96, 97, 96, 97 ]

		if flag_plotAll:	# and we're plotting the inputs...
			plotstring.append("'%s' using 1:3:2:6:5 with candlesticks whiskerbars linestyle %s title 'All', '' using 1:4:4:4:4 with candlesticks linestyle %s notitle" % (filename, temp[0], temp[1] ))
			temp.pop(0)
			temp.pop(0)

		if flag_plotProcessing:	
			plotstring.append("'%s' using 1:11:10:14:13 with candlesticks whiskerbars linestyle %s title 'Processing', '' using 1:12:12:12:12 with candlesticks linestyle %s notitle" % (filename, temp[0], temp[1] ))
			temp.pop(0)
			temp.pop(0)

		if flag_plotInput:	
			plotstring.append("'%s' using 1:19:18:22:21 with candlesticks whiskerbars linestyle %s title 'Input', '' using 1:20:20:20:20 with candlesticks linestyle %s notitle" % (filename, temp[0], temp[1] ))
			temp.pop(0)
			temp.pop(0)

	if flag_plotMean or flag_plotPoints:

		if flag_plotLegend: 
			if flag_plotErrorbars: temp = [ 1, 54, 2, 55, 3, 56 ]
			else: temp = [ 1, 2, 3 ]
		else:
			if flag_plotErrorbars: temp = [ 99, 98, 99, 98, 99, 98 ]
			else: temp = [ 99, 99, 99 ]

		if flag_plotAll:
			plotstring.append("'%s' using 1:7 linestyle %s title 'mean All'" % (filename, temp[0]) )
			temp.pop(0)
			if flag_plotErrorbars: 
				plotstring.append("'' using 1:7:8 with yerrorbars linestyle %s notitle" % (temp[0]))
				temp.pop(0)
		if flag_plotProcessing:
			plotstring.append("'%s' using 1:15 linestyle %s title 'mean Pro'" % (filename, temp[0]) )
			temp.pop(0)
			if flag_plotErrorbars: 
				plotstring.append("'' using 1:15:16 with yerrorbars linestyle %s notitle" % (temp[0]))
				temp.pop(0)
		if flag_plotInput:
			plotstring.append("'%s' using 1:23 linestyle %s title 'mean Inp'" % (filename, temp[0]) )
			temp.pop(0)
			if flag_plotErrorbars: 
				plotstring.append("'' using 1:23:24 with yerrorbars linestyle %s notitle" % (temp[0]))
				temp.pop(0)

		if flag_plotWhiskers:	# if we are plotting Whiskers, go back through the plotstring and remove some titles
			for i in range(len(plotstring)):
				if "title 'mean " in plotstring[i]: plotstring[i] = re.sub("title 'mean [^']*'", 'notitle' ,plotstring[i])

	##### NOW FOR THE AVERAGES ###########
	if flag_plotWhiskers_AVERAGE:	# are we doing the whiskers for the AVERAGE?
		temp = [ 103, 102, 103, 102, 103, 102 ]

		if flag_plotAll:	# and we're plotting the inputs...
			plotstring.append("'%s' using 1:3:2:6:5 with candlesticks whiskerbars linestyle %s title 'All means', '' using 1:4:4:4:4 with candlesticks linestyle %s notitle" % (Avrfilename, temp[0], temp[1] ))
			temp.pop(0)
			temp.pop(0)

		if flag_plotProcessing:	
			plotstring.append("'%s' using 1:11:10:14:13 with candlesticks whiskerbars linestyle %s title 'Processing means', '' using 1:12:12:12:12 with candlesticks linestyle %s notitle" % (Avrfilename, temp[0], temp[1] ))
			temp.pop(0)
			temp.pop(0)

		if flag_plotInput:	
			plotstring.append("'%s' using 1:19:18:22:21 with candlesticks whiskerbars linestyle %s title 'Input means', '' using 1:20:20:20:20 with candlesticks linestyle %s notitle" % (Avrfilename, temp[0], temp[1] ))
			temp.pop(0)
			temp.pop(0)

	if flag_plotMean_AVERAGE:

		if flag_plotErrorbars_AVERAGE: temp = [ 100, 101, 100, 101, 100, 101 ]
		else: temp = [ 100, 100, 100 ]

		if flag_plotAll:
			plotstring.append("'%s' using 1:7 linestyle %s title 'meta-mean All'" % (Avrfilename, temp[0]) )
			temp.pop(0)
			if flag_plotErrorbars: 
				plotstring.append("'' using 1:7:8 with yerrorbars linestyle %s notitle" % (temp[0]))
				temp.pop(0)
		if flag_plotProcessing:
			plotstring.append("'%s' using 1:15 linestyle %s title 'meta-mean Pro'" % (Avrfilename, temp[0]) )
			temp.pop(0)
			if flag_plotErrorbars: 
				plotstring.append("'' using 1:15:16 with yerrorbars linestyle %s notitle" % (temp[0]))
				temp.pop(0)
		if flag_plotInput:
			plotstring.append("'%s' using 1:23 linestyle %s title 'meta-mean Inp'" % (Avrfilename, temp[0]) )
			temp.pop(0)
			if flag_plotErrorbars: 
				plotstring.append("'' using 1:23:24 with yerrorbars linestyle %s notitle" % (temp[0]))
				temp.pop(0)

		if flag_plotWhiskers_AVERAGE:	# if we are plotting Whiskers, go back through the plotstring and remove some titles
			for i in range(len(plotstring)):
				if "title 'meta-mean " in plotstring[i]: plotstring[i] = re.sub("title 'meta-mean [^']*'", 'notitle' ,plotstring[i])



	plotstring = 'plot ' + ', '.join(plotstring)
	return plotstring

"""
	# Okay, we've made our regular plotstring, now to make the smoothed plotstring.  We always make the string, even if we don't always plot it.
	global GNUPLOT_SMOOTHING_FUNCTION
	for line in plotstring:
		if 'yerrorbars' in line:		# the yerrorbars style doesnt support smoothing
			plotstringsmooth.append( line )
		else:
			plotstringsmooth.append( line + ' smooth %s' % ( GNUPLOT_SMOOTHING_FUNCTION ))

	# Okay, we've made our regular plostring, but now we're going to completely transform it if we're multiplotting...
	if flag_multiplot:
		global multiplotmaxtimesteps
		mplotstrings=[]
		mplotstringssmooth=[]
		for i in range(0, len(RUN_DIRS)):
			# set the title for each miniplot
			miniplottitle=(RUN_DIRS[i].split('/')[-1]).replace('_','_')
			mplotstrings.append( 'set title "%s" offset 0,-1' % (miniplottitle) )			
			mplotstringssmooth.append( 'set title "%s" offset 0,-1' % (miniplottitle) )

			# set the xrange and xtics for each miniplot
			mplotstrings.append( 'set xrange[0:%s]' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )	
			mplotstrings.append( 'set xtics 0, %s' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )
			mplotstringssmooth.append( 'set xrange[0:%s]' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )
			mplotstringssmooth.append( 'set xtics 0, %s' % (multiplotmaxtimesteps[RUN_DIRS[i]]) )

			# make the plotstrings
			mplotstrings.append( 'plot ' + ', '.join( plotstring[i:num_rundir_lines:len(RUN_DIRS)] ) )
			mplotstringssmooth.append( 'plot ' + ', '.join( plotstringsmooth[i:num_rundir_lines:len(RUN_DIRS)] ) )
""" # END
""" # BEGIN			
			# fix the linestyles within the plotstring we just made
			regularlinestyles=re.findall("linestyle [0-9]*", mplotstrings[-1])
			currentstyle=1
			for regularlinestyle in regularlinestyles:
				mplotstrings[-1] = mplotstrings[-1].replace( regularlinestyle, 'linestyle %s' % (currentstyle) )
				mplotstringssmooth[-1] = mplotstringssmooth[-1].replace( regularlinestyle, 'linestyle %s' % (currentstyle) )
				currentstyle += 1
		
		# and join it all into one lovely string separated by newlines
		plotstring = '\n'.join( mplotstrings )
		plotstringsmooth= '\n'.join( mplotstringssmooth )
		# now do a string replace for each PARAM to make the Legends not have the run/ directory in them.
		for param in PARAMS:
			plotstring = re.sub("title '%s[^']*'" % (param), "title '%s'" % (param), plotstring )
			plotstringsmooth = re.sub("title '%s[^']*'" % (param), "title '%s'" % (param), plotstringsmooth )

	else:			# if multiplot is NOT turned on, just join the strings.
		plotstring='plot ' + ', '.join( plotstring )			 # begin with 'plot' and join each line to be plotted with a coma.
		plotstringsmooth='plot ' + ', '.join( plotstringsmooth)		 # begin with 'plot' and join each line to be plotted with a coma.

""" # END
######################################

def sample_mean( list ):
	N = len(list)
	mean = sum(list) / N

	SSE=0
	for item in list: SSE += (item - mean)**2.0

	try: variance = SSE / (N-1)
	except: variance = 0

	stderr = ( variance ** 0.5 ) / (N**0.5)	# stderr = stddev / sqrt(N)
	return mean, stderr

def check_parameters( argv ):
	try: opts, args = getopt.getopt( argv, "enwENWlpAPIM:")
	except getopt.GetoptError: print_usage_and_exit() 

#	print "opts=%s" % ( opts )
#	print "args=%s" % ( args)

	global flag_plotLegend, flag_plotErrorbars, flag_multiplot, flag_plotMean, flag_plotPoints, PASSED_DIRECTORY, multiplotDimX, multiplotDimY	# grant access to the global variables we're going to modify
	global flag_plotErrorbars_AVERAGE, flag_plotMean_AVERAGE, flag_plotWhiskers, flag_plotWhiskers_AVERAGE
	global flag_plotAll, flag_plotProcessing, flag_plotInput
	# Set our plot flags
	for opt in opts:

		if   '-e' in opt:
			flag_plotErrorbars = True
		elif '-n' in opt:
			flag_plotMean = True
		elif '-w' in opt:
			flag_plotWhiskers = True
		elif '-E' in opt:
			flag_plotErrorbars_AVERAGE = True
		elif '-N' in opt:
			flag_plotMean_AVERAGE = True
		elif '-W' in opt:
			flag_plotWhiskers_AVERAGE = True
		elif '-l' in opt:
			flag_plotLegend = True
		elif '-p' in opt:
			flag_plotPoints = True
		elif '-A' in opt:
			flag_plotAll = True
		elif '-P' in opt:
			flag_plotProcessing = True
		elif '-I' in opt:
			flag_plotInput = True
		elif '-M' in opt:
			flag_multiplot = True
			multiplotDimX, multiplotDimY = map(int, (opt[1]).split('x'))
		else:
			print "* Error: Do not know argument '%s'" % (opt)
			print_usage_and_exit()

	# Some default settings if the user doesn't specify anything...
	if not flag_plotInput and not flag_plotAll: flag_plotProcessing = True	# if no -[API] is specified, assume -P.

	if not flag_plotWhiskers and not flag_plotWhiskers_AVERAGE and not flag_plotMean_AVERAGE and not flag_plotPoints:
		flag_plotMean = True						# if nothing to plot is specified, plot the meanlines.

	# If we don't have a single argument, exit.
	if len(args) != 1: print_usage_and_exit()
	
	PASSED_DIRECTORY = args[0].rstrip( '/' )	# removing any trailing slash

############################### Finished the parsing of the input parameters, now to look at the RUN_DIRS

	global RUN_DIRS

	if not os.path.isdir( PASSED_DIRECTORY ):			# if the passed directory wasn't a directory, exit.
		print "* Error: '%s' isn't a directory." % ( PASSED_DIRECTORY )
		print_usage_and_exit()

	for i in RUN_DIRS:
		if os.path.isfile( PASSED_DIRECTORY + '/brain/'+ i + '/' + inputplotfilename ): 	# if 'directory' is itself a run/ directory, just use that.
			RUN_DIRS[i].append( PASSED_DIRECTORY )

		else:						# 'directory' is a directory, but is NOT a run/ directory itself.  Is it a list of run directories?
			for potential_rundir in os.listdir( PASSED_DIRECTORY ):
				if os.path.isfile( PASSED_DIRECTORY + '/' + potential_rundir + '/brain/' + i + '/' + inputplotfilename ):
					RUN_DIRS[i].append( PASSED_DIRECTORY + '/' + potential_rundir )	# if potential_directory is a run/ directory, add it.

		if flag_multiplot and len(RUN_DIRS[i]) > multiplotDimX * multiplotDimY:		# if multiplot is turned on only go up to dimX*dimY
			print "* Warning: There are %s run/ directories in %s, but multiplot can only plot %s plots -- only using the first %s." % ( len(RUN_DIRS[i]), PASSED_DIRECTORY, multiplotDimX * multiplotDimY, multiplotDimX * multiplotDimY )
			RUN_DIRS[i] = RUN_DIRS[i][: (multiplotDimX * multiplotDimY)]

		print "%sRUN_DIRS= %s" % ( i, RUN_DIRS[i] )

	if not RUN_DIRS['bestRecent'] and not RUN_DIRS['Recent']:
		print "* Error: There were no Polyworld run/ directories in %s." % ( PASSED_DIRECTORY )
		sys.exit(1)

##################################################################################
#This function gets the bestRecentBrainFunctionRecordFrequency as specified in the worldfile for a given run/ directory.
##################################################################################
def get_bestRecentBrainFunctionRecordFrequency( run_dir ):
	bestRecentBrainFunctionRecordFrequency=-1

	try:
		worldfile = open( run_dir + '/worldfile' )
		for line in worldfile:
			if 'bestRecentBrainFunctionRecordFrequency' in line:
				bestRecentBrainFunctionRecordFrequency = int( re.match('([0-9]*)', line).groups(0)[0] )	
		worldfile.close()
	except:
		print "* Error: Could not open '%s/worldfile'. Exiting." % ( run_dir )
		sys.exit(1)

	if bestRecentBrainFunctionRecordFrequency == -1:
		print "* Error: Couldn't find a value for 'bestRecentBrainFunctionRecordFrequency' in %s/worldfile.  Exiting." % (run_dir)
		sys.exit(1)
		
	return bestRecentBrainFunctionRecordFrequency
########################################################################################################################		
########################################################################################################################		
########################################################################################################################		
### Real program begins here

check_parameters( sys.argv[1:] )		# don't send it the first item in the sys.argv list because that's this programs filename
print "- plotPoints=%s plotMean=%s plotErrorbars=%s plotWhiskers=%s plotLegend=%s" % ( flag_plotPoints, flag_plotMean, flag_plotErrorbars, flag_plotWhiskers, flag_plotLegend )
print "- plotMeanAverage=%s plotErrorbarsAverage=%s plotWhiskersAverage=%s" % ( flag_plotMean_AVERAGE, flag_plotErrorbars_AVERAGE, flag_plotWhiskers_AVERAGE )
print "- plotAll=%s plotProcessing=%s plotInput=%s" % ( flag_plotAll, flag_plotProcessing, flag_plotInput )

averagetimestepinterval = get_bestRecentBrainFunctionRecordFrequency( RUN_DIRS['bestRecent'][0]  )
print "- Average interval = %s" % (averagetimestepinterval)


DATA = { 'bestRecent': {}, 'Recent': {} }	# make a dictionary of dictionaries
MAXTIMESTEP=0
for whichrecent in RUN_DIRS:
	for rundir in RUN_DIRS[whichrecent]:
		filename = rundir + '/brain/' + whichrecent + '/' + inputplotfilename
		inputplotfile = open( filename )
		for line in inputplotfile:
			if line.startswith('#'):	# if the line is a comment (begins with #)
				continue;
			line_array=line.split('\t')
			t = int(line_array[0])
			if t not in DATA[whichrecent]:
				DATA[whichrecent][t] = {}
				DATA[whichrecent][t]['Pro']=[]
				DATA[whichrecent][t]['All']=[]
				DATA[whichrecent][t]['Inp']=[]

			DATA[whichrecent][t]['All'].append( line_array[6 ] ) 
			DATA[whichrecent][t]['Pro'].append( line_array[14] )
			DATA[whichrecent][t]['Inp'].append( line_array[22] )
			if t > MAXTIMESTEP: MAXTIMESTEP = t
#			print "linearray=%s" % (line_array ) 


# Open the file that we're going to store the data on the averages.
for whichrecent in ('bestRecent','Recent'):
	tempfile=open( tempfilename + '.' + whichrecent, 'w' )
	print " - tempfilename=%s" % ( tempfilename + '.' + whichrecent )
	for t in [0] + range(averagetimestepinterval,MAXTIMESTEP+averagetimestepinterval,averagetimestepinterval):
		list_to_print = [ t ]
		for area in ('All','Pro','Inp'):
			DATA[whichrecent][t][area] = map( float, DATA[whichrecent][t][area] )	# make sure they are all floats so we comparing correctly.
			minimum=min( DATA[whichrecent][t][area] )
			maximum=max( DATA[whichrecent][t][area] )
			median, lowerhalf, upperhalf = get_median( DATA[whichrecent][t][area] )
			q1=get_median( lowerhalf )[0]
			q3=get_median( upperhalf )[0]
			mean, mean_stderr = sample_mean( DATA[ whichrecent ][t][area] )
			list_to_print.append( "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" % ( minimum, q1, median, q3, maximum, mean, mean_stderr, len( DATA[whichrecent][t][area]) ) )
			del DATA[whichrecent][t][area]		# Don't need this anymore
		list_to_print = map(str, list_to_print)
		tempfile.write( '\t'.join( list_to_print ) )
		tempfile.write('\n')
		tempfile.flush()
	tempfile.close()

#tempfilename='/tmp/,plotNeuralComplexity_%s.plt' % ( os.getpid() )		# this file will contain the raw data
	
print "maxtimestep=%s" % ( MAXTIMESTEP )
outputcontents = [ GNUPLOT_SETTINGS ]

for whichrecent in RUN_DIRS:
	for rundir in RUN_DIRS[whichrecent]:
#		print "rundir=%s" % ( rundir )
		filename = rundir + '/brain/' + whichrecent + '/' + inputplotfilename
		Avrfilename =  tempfilename + '.' + whichrecent
		outputcontents.append( GET_GNUPLOT_DYNAMIC_SETTINGS( whichrecent ) )
		outputcontents.append( GET_GNUPLOT_PLOTSTRING(filename, Avrfilename) )
	outputcontents.append( GET_GNUPLOT_END_SETTINGS() )

outputfileGNU=open( outputfilenameGNU, 'w' )
outputfileGNU.write( '\n'.join(outputcontents) )
outputfileGNU.close()
print "- Executing gnuplot commands in '%s'" % ( outputfilenameGNU )
os.system( 'gnuplot '+ outputfilenameGNU )

"""
MINSTATFREQ = get_minstatfreq( RUN_DIRS )	# this will be used at the end when making the .plt file
GNUPLOT_TOPRIGHT_LABEL.append( "Generated `date +%Y-%m-%d` by `whoami`")

MAXTIMESTEP = 0					# this will be used at the end when making the .plt file

# Print some data for the user.

DATA = { }
sed_out= "[^0-9 \.\-]"
for param in PARAMS:
	param_withoutcrunch = param.rstrip('0123456789').rstrip('#')	# take off the numbers, then take off the '#'

	column = int( param.replace( param_withoutcrunch + "#", '' ) )
	if re.search( '[0-9 \.\-]', param_withoutcrunch):		# CAREFUL.  This regex MUST be the exact inverse of variable 'sed_out'
		column = column + 1		# hack to get the correct column if our parameter has a number in it.

	print param + ': ',

	for RUN_DIR in RUN_DIRS:
		DATAkey = param + '~~' + RUN_DIR
		DATA[ DATAkey ] = { }					# create a dictionary of dictionaries

		print "%s..." % ( RUN_DIR ),
		sys.stdout.flush()

		files = os.listdir( RUN_DIR + '/stats/' )
		timesteps = [ ]
		for statfile in files:					# go through each file in run/stats/ to make sure it is a stat.#### file
			if re.match( 'stat\.[0-9]', statfile ):	# statfile matches the format of: stat.#### ...
				timesteps.append( int(statfile.lstrip('stat\.')) )

		timesteps.sort()

		if RUN_DIR not in multiplotmaxtimesteps:				# this is for the xrange dynamic setting for multiplots
			multiplotmaxtimesteps[RUN_DIR]=timesteps[-1]

		if timesteps[-1] > MAXTIMESTEP: MAXTIMESTEP = timesteps[-1]		# this is for later, as well as the xrange[] dynamic setting

#		print "timesteps='%s'" % ( timesteps )
		for timestep in timesteps:
			cmd = "grep '^[ ]*%s[ 	]' %s/stats/stat.%s | sed -e 's/%s//g'| tr -s ' '" % ( param_withoutcrunch, RUN_DIR, timestep, sed_out )	# create our grep command
			# join into a string; remove tabs, newlines, and spaces from the beginning and end; then split by spaces back into a list.
			result = "".join( os.popen(cmd).readlines() ).strip("\n 	").split(' ')

			if column > len(result):
				print "* Error: You specified column '%s', but there are only %s columns for parameter '%s'.  Exiting." % ( column, len(result), param_withoutcrunch)
				sys.exit(1)
			value = result[column-1]			# lists are zero based.  So decrement column by 1.

#			print "cmd=%s result=%s column=%s value=%s" % ( cmd, result, column, value )
			DATA[ DATAkey ][ timestep ] = value
	print ""	# print a newline

	if flag_plotMean:							# if we're plotting the mean compute that now.
		DATA[ param + '~~AVERAGE'] = {}					# make a new dictionary for the average
		if flag_plotErrorbars: DATA[ param + '~~AVERAGE_STDERR'] = {}	# make dictionary for the StdErr bars on the mean, (if we're doing that)

		meantimesteps= map( int, DATA[ param + '~~' + RUN_DIRS[0] ].keys() )	# get the timesteps from the first directory; convert to ints; assign to 'timesteps'
		meantimesteps.sort()
#debug		print "meantimesteps=%s" % ( meantimesteps )


		for t in meantimesteps:						# foreach timestep in the first RUN_DIR...
			samples=[ ]						
			for RUN_DIR in RUN_DIRS:
				DATAkey = param + '~~' + RUN_DIR		# for convenience so we dont have to keep specifying it manually

				if t in DATA[ DATAkey ]:			# if the RUN_DIR has a value for the timestep we're interested in (in all non-pathological cases this will be true 100% of the time)...
					samples.append( float(DATA[ DATAkey ][t]) )	
				else:
					print "* Warning: run/ directory '%s' does not have timestep %s -- not including it in any averages for timestep %s." % ( RUN_DIR, t, t )

			DATA[ param + '~~AVERAGE' ][t] = sum(samples ) / len(samples)				# store the average into the DATA meta-dictionary
			if flag_plotErrorbars: DATA[ param + '~~AVERAGE_STDERR'  ][t] =  sample_stderr( samples ) 	# store the stderr into DATA meta-dictionary

#			print "DATA[%s~~AVERAGE][%s]=%s" % ( param, t, DATA[param + '~~AVERAGE'][t] )
##########################################################################################################################################
# Okay, we've made out DATA dictionary with all params/runs, param averages, and param stderrs.
# Now Lets Plot!
##########################################################################################################################################

# First, build a definitive lists of all timesteps we have in our DATA meta-dictionary
print "- MAXTIMESTEP = %s" % ( MAXTIMESTEP )
timesteps=[ 1 ]

timesteps.extend( range(MINSTATFREQ, MAXTIMESTEP+MINSTATFREQ, MINSTATFREQ) )
o = open( tempfilename , 'w' )			# open a tempfile at /tmp/,<pid>.plt

# print the header for the tempfile

# Format for the tempfile is:  timestep param1run1 param1run2 param1run3 param2run1 param2run3 param2run3 param1AVR param1STDERR param2AVR param2STDERR
# In words: param1 comes, then param2 comes, then param1 AVR/STDERR and param2 AVR/STDERR
tempcol=2
for param in PARAMS:
	for RUN_DIR in RUN_DIRS:
		o.write( "# col %s: param='%s' dir=%s\n" % ( tempcol, param, RUN_DIR ) )
		tempcol += 1

if flag_plotMean:
	for param in PARAMS:
		o.write( "# col %s: param='%s' AVERAGE\n" % ( tempcol, param ) )
		tempcol += 1
		if flag_plotErrorbars:
			o.write( "# col %s: param='%s' STDERR\n" % ( tempcol, param ) )
			tempcol += 1

# for archival purposes write the gnuplot program to the top of the line
o.write( ("\n%s\n-----\n%s\n------\n%s\n" % (GNUPLOT_SETTINGS, GET_GNUPLOT_DYNAMIC_SETTINGS(), GET_GNUPLOT_PLOTSTRING())).replace('\n', '\n#').rstrip('#') )

########################## finished printing the header for the tempfile.  Now lets print the actual data!
for t in timesteps:
	line_to_write = [ '%s\t' % ( t ) ]				# each line begins with the timestep
	for param in PARAMS:	
		for RUN_DIR in RUN_DIRS:
			DATAkey="%s~~%s" % ( param, RUN_DIR )		# so we don't have to keep making this
			if t not in DATA[ DATAkey ]:			# if there is no value for timestep t...put a question mark there
				line_to_write.append( '?\t' )
			else:
				line_to_write.append( '%s\t' % ( DATA[ DATAkey ][t] ) )

	if flag_plotMean:						# put the averages after all of the RUN_DIR values, if we're doing that.
		for param in PARAMS:
			line_to_write.append( '%s\t' % (DATA[ param + '~~AVERAGE' ][t]) )
			if flag_plotErrorbars: line_to_write.append( '%s\t' % (DATA[ param + '~~AVERAGE_STDERR' ][t]) )
				
	line_to_write[-1] = line_to_write[-1].rstrip("\t")			# strip the final tab from the line.		
	o.write( "".join(line_to_write) + "\n" )

o.close()
print "Finished writing to '%s'." % ( tempfilename )

# Plot the unsmoothed
gnufile = open( gnufilename, 'w' ) 
gnufile.write( "%s\n%s\n%s\n%s\n" % ( GNUPLOT_SETTINGS, GET_GNUPLOT_DYNAMIC_SETTINGS(), GET_GNUPLOT_PLOTSTRING()[0], GET_GNUPLOT_END_SETTINGS() ) )
gnufile.close()
os.system( 'gnuplot '+ gnufilename )

if flag_plotSmooth:		# Second, plot the smoothed in a new window (if we're doing that)
	GNUPLOT_TOPRIGHT_LABEL.append( "Smoothed with '%s'" % (GNUPLOT_SMOOTHING_FUNCTION) )
	gnufileS = open( gnufilename + 'S', 'w' )
	gnufileS.write( "%s\n%s\n%s\n%s\n" % ( GNUPLOT_SETTINGS, GET_GNUPLOT_DYNAMIC_SETTINGS(), GET_GNUPLOT_PLOTSTRING()[1], GET_GNUPLOT_END_SETTINGS() ) )
	gnufileS.close()
	os.system( 'gnuplot '+ gnufilename + 'S' )
"""
print "Done!"
