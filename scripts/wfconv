#!/usr/bin/env python

from common_functions import err

DEBUG = False

class Property:
    def __init__( self, name, type, value ):
        self.name = name
        self.type = type
        self.value = value

class Container:
    def __init__( self ):
        self.parent = None
        self.props = {}
        self.order = []

    def add( self, name, type, value ):
        if DEBUG:
            print 'parsed', name, ' as ', value

        prop = Property( name, type, value )

        self.props[name] = prop
        self.order.append( prop )
        if prop.type == 'container':
            value.parent = self
            value.name = name

    def remove( self, name ):
        prop = self.props[name]
        del self.props[name]
        self.order.remove( prop )

    def get( self, name ):
        return self.props[ name ]

    def fullname( self, name ):
        if self.parent == None:
            return name

        ancestors = self.parent.fullname( self.name )
        if isinstance( name, int ):
            return "%s[%d]" % (ancestors, name)
        else:
            return "%s.%s" % (ancestors, name)

    def isarray( self ):
        return all( map(lambda x: isinstance(x, int), self.props) )

    def printOldFormat( self ):
        for prop in self.order:
            value = prop.value
            name = prop.name
            if prop.type == 'container':
                value.printOldFormat()
            else:
                if isinstance( value, bool ):
                    value = '1' if value else '0'
                elif isinstance( value, list ):
                    value = ' '.join( map(str,value) )
                print "%-30s %s" % ( value, self.fullname(name) )

    def printNewFormat( self, schema = False, indent = "" ):
        def __print( name, data ):
            print "%s%-25s %s" % (indent, name, data)


        lastprop = self.order[-1]

        for prop in self.order:
            value = prop.value

            if prop.type == 'container':
                if not self.isarray():
                    if value.isarray():
                        open = '['
                        close = ']'
                    else:
                        open = '{'
                        close = '}'
                    #__print( prop.name + " " + open, "" )
                    __print( prop.name +" "+open, "" )

                value.printNewFormat( schema, indent + "  " )

                if not self.isarray():
                    #__print( close, "" )
                    __print( close, "" )
                else:
                    if prop != lastprop:
                        __print( ",", "" )
            elif prop.type == 'barrierkeyframe':
                if schema:
                    __print( "T", 'int' )
                    __print( "X1", 'float' )
                    __print( "Z1", 'float' )
                    __print( "X2", 'float' )
                    __print( "Z2", 'float' )
                else:
                    __print( "T", value[0] )
                    __print( "X1", value[1] )
                    __print( "Z1", value[2] )
                    __print( "X2", value[3] )
                    __print( "Z2", value[4] )
            elif prop.type == 'color':
                __print( prop.name + " {", "" )
                indent += "  "
                if schema:
                    __print( "R", 'float' )
                    __print( "G", 'float' )
                    __print( "B", 'float' )
                else:
                    __print( "R", value[0] )
                    __print( "G", value[1] )
                    __print( "B", value[2] )
                indent = indent[:-2]
                __print( "}", "" )
            else:
                if schema:
                    __print( prop.name, prop.type )
                else:
                    __print( prop.name, prop.value )


################################################################################
################################################################################
###
### FUNCTION printNewFormat()
###
################################################################################
################################################################################
def printNewFormat( container, schema = False ):
    container.remove( 'NumBarriers' )
    container.remove( 'NumDomains' )

    barriers = container.get( 'Barriers' )
    for barrier in barriers.value.props.values():
        barrier.value.remove( 'NumKeyFrames' )

    domains = container.get( 'Domains' )
    for domain in domains.value.props.values():
        domain.value.remove( 'NumFoodPatches' )
        domain.value.remove( 'NumBrickPatches' )

    container.remove( 'Version' )
    
    print '100  Version'
    print

    container.printNewFormat( schema )

################################################################################
################################################################################
###
### FUNCTION parse()
###
################################################################################
################################################################################
def parse( path ):
    f = open( path, 'r' )

    def __line():
        while True:
            l = f.readline()

            tokens = l.split()
            n = len(tokens)
            if n == 1:
                err( "unexpected format: '%s'" % l )

            if DEBUG:
                print 'READ LINE:', l

            if n > 0:
                return tokens[-1], tokens[:-1]

    class local:
        container = Container()

    def push( name, childContainer ):
        local.container.add( name, 'container', childContainer )
        local.container = childContainer
        return childContainer

    def pop( name ):
        assert( name == local.container.name )
        local.container = local.container.parent

    wfversion = -1

    def __scalar( name, version, default, type, func_parse ):
        if version == None or version <= wfversion:
            label, val = __line()
            if len(val) != 1:
                err( "expecting scalar for %s, found (%s,%s)" % (name, label, val) )
            val = func_parse( val[0] )

            local.container.add( name, type, val )
        else:
            val = default

        return val

    def __tuple( name, count, version, default, type, func_parse ):
        if version == None or version <= wfversion:
            label, val = __line()
            if len(val) != count:
                err( "expecting tuple with %d elements for %s, found (%s,%s)" % (count, name, label, val) )
            val = map( func_parse, val )

            local.container.add( name, type, val )
        else:
            val = default


        return val

    def pint( name, version = None, default = None ):
        return __scalar(name, version, default, 'int', int)

    def pfloat( name, version = None, default = None ):
        return __scalar(name, version, default, 'float', float)

    def pbool( name, version = None, default = None ):
        return __scalar(name, version, default, 'bool', lambda x: x != '0' )

    def penum( name, values, version = None, default = None, values_new = None ):
        if values_new == None:
            values_new = values
        type = 'enum(' + ','.join(values_new) + ')'
        val =  __scalar(name, version, default, type, lambda x: x )
        assert( val in values )
        return val

    def pcolor( name, version = None, default = None ):
        return __tuple( name, 3, version, default, 'color', float )

    def pbarrierkeyframe( name ):
        label, val = __line()
        if len(val) != 5:
            err( "expecting barrierkeyframe with 5 elements for %s, found (%s,%s)" % (name, label, val) )
        val = [int(val[0])] + map( float, val[1:] )

        local.container.add( name, 'barrierkeyframe', val )

        return val

    def pbarrierpos( name ):
        label, val = __line()
        if len(val) != 4:
            err( "expecting barrierkeyframe with 4 elements for %s, found (%s,%s)" % (name, label, val) )
        val = map( float, val )

        local.container.add( name, 'barrierpos', val )

        return val

    def pignore( name ):
        __line()

            

    wfversion = pint( 'Version' )

    pbool( 'LockStepWithBirthsDeathsLog', 25, False )
    pint( 'MaxSteps', 18, 0 )
    pbool( 'EndOnPopulationCrash', 48, False )
    pignore( 'DoCpuWork' )
    pint( 'DumpFrequency' )
    pint( 'StatusFrequency' )
    pbool( 'Edges' )
    pbool( 'WrapAround' )
    pbool( 'Vision' )
    pbool( 'ShowVision' )
    pbool( 'StaticTimestepGeometry', 34, False )
    pbool( 'ParallelInitAgents', 55, False )
    pbool( 'ParallelInteract', 55, False )
    pbool( 'ParallelBrains', 55, True )
    pint( 'MinWin' )
    pfloat( 'MaxVelocity' )
    pint( 'MinNumAgents' )
    pint( 'MaxNumAgents' )
    pint( 'InitNumAgents' )
    pint( 'NumberToSeed', 9, 0 )
    pfloat( 'ProbabilityOfMutatingSeeds', 9, 0.0 )
    pbool( 'SeedFromFile', 45, False )
    pbool( 'PositionSeedsFromFile', 49, False )
    pint( 'MiscAgents' )

    if wfversion >= 32:
        pint( 'InitFoodCount' )
        pint( 'MinFoodCount' )
        pint( 'MaxFoodCount' )
        pint( 'MaxFoodGrown' )
        pfloat( 'FoodRate' )

    pfloat( 'FoodRemoveEnergy', 46, 0.0 )
    pint( 'PositionSeed' )
    pint( 'GenomeSeed' )
    pint( 'SimulationSeed', 44, 0.0 )
    
    if wfversion < 32:
        pint( 'MinFoodCount' )
        pint( 'MaxFoodCount' )
        pint( 'MaxFoodGrown' )
        pint( 'InitFoodCount' )
        pfloat( 'FoodRate' )

    penum( 'AgentsRfood', ['0','1','F'], values_new = ['False','True', 'Fight'] )
    pint( 'Fitness1Frequency' )
    pint( 'Fitness2Frequency' )
    pint( 'NumberFit' )
    pint( 'NumberRecentFit', 14, 10 )
    pfloat( 'EatFitnessParameter' )
    pfloat( 'MateFitnessParameter' )
    pfloat( 'MoveFitnessParameter' )
    pfloat( 'EnergyFitnessParameter' )
    pfloat( 'AgeFitnessParameter' )
    pfloat( 'MinFoodEnergy' )
    pfloat( 'MaxFoodEnergy' )
    pfloat( 'Size2Energy' )
    pfloat( 'Eat2Consome' )
    penum( 'GenomeLayout', ['L','N'], 53, 'L' )
    pbool( 'EnableMateWaitFeedback', 48, False )
    pbool( 'EnableSpeedFeedback', 38, False )
    pbool( 'EnableGive', 38, False )
    pbool( 'EnableCarry', 39, False )
    pint( 'MaxCarries', 39, 0 )
    pbool( 'CarryAgents', 41, True )
    pbool( 'CarryFood', 41, True )
    pbool( 'CarryBricks', 41, True )
    pbool( 'ShieldAgents', 41, False )
    pbool( 'ShieldFood', 41, False )
    pbool( 'ShieldBricks', 41, False )
    pfloat( 'CarryPreventsEat', 41, 0.0 )
    pfloat( 'CarryPreventsFight', 41, 0.0 )
    pfloat( 'CarryPreventsGive', 41, 0.0 )
    pfloat( 'CarryPreventsMate', 41, 0.0 )
    pignore( 'MinInternalNeurons' )
    pignore( 'MaxInternalNeurons' )
    pint( 'MinVisPixels' )
    pint( 'MaxVisPixels' )
    pfloat( 'MinMutationRate' )
    pfloat( 'MaxMutationRate' )
    pint( 'MinNumCpts' )
    pint( 'MaxNumCpts' )
    pint( 'MinLifeSpan' )
    pint( 'MaxLifeSpan' )
    pint( 'MateWait' )
    pint( 'InitMateWait' )
    pint( 'EatMateSpan', 29, 0 )
    pfloat( 'MinStrength' )
    pfloat( 'MaxStrength' )
    pfloat( 'MinAgentSize' )
    pfloat( 'MaxAgentSize' )
    pfloat( 'MinMaxEnergy' )
    pfloat( 'MaxMaxEnergy' )
    pfloat( 'MinMateEnergy' )
    pfloat( 'MaxMateEnergy' )
    pfloat( 'MinMateFrac' )
    pfloat( 'MinMaxSpeed' )
    pfloat( 'MaxMaxSpeed' )
    pfloat( 'Speed2DPosition' )
    pfloat( 'Yaw2DYaw' )
    pfloat( 'MinLRate' )
    pfloat( 'MaxLRate' )
    pfloat( 'MinFocus' )
    pfloat( 'MaxFocus' )
    pfloat( 'AgentFOV' )
    pfloat( 'MaxSizeAdvantage' )
    penum( 'BodyGreenChannel', ['I','L','$float'], 38, 'I' )
    penum( 'NoseColor', ['L','$float'], 38, 'L' )
    pfloat( 'Power2Energy' )
    pfloat( 'Eat2Energy' )
    pfloat( 'Mate2Energy' )
    pfloat( 'Fight2Energy' )
    pfloat( 'MinSizePenalty', 47, 0 )
    pfloat( 'MaxSizePenalty' )
    pfloat( 'Speed2Energy' )
    pfloat( 'Yaw2Energy' )
    pfloat( 'Light2Energy' )
    pfloat( 'Focus2Energy' )
    pfloat( 'Pickup2Energy', 39, 0.5 )
    pfloat( 'Drop2Energy', 39, 0.001 )
    pfloat( 'CarryAgent2Energy', 39, 0.05 )
    pfloat( 'CarryAgentSize2Energy', 39, 0.05 )
    pfloat( 'CarryFood2Energy', 39, 0.01 )
    pfloat( 'CarryBrick2Energy', 39, 0.01 )
    pfloat( 'MaxSynapse2Energy' )
    pfloat( 'FixedEnergyDrain' )
    pfloat( 'DecayRate' )
    pfloat( 'AgentHealingRate', 18, 0.0 )
    pfloat( 'EatThreshold' )
    pfloat( 'MateThreshold' )
    pfloat( 'FightThreshold' )
    pfloat( 'FightFraction', 43, 1.0 )
    pfloat( 'GiveThreshold', 38, 0.2 )
    pfloat( 'GiveFraction', 38, 1.0 )
    pfloat( 'PickupThreshold', 39, 0.5 )
    pfloat( 'DropThreshold', 39, 0.5 )
    pfloat( 'MiscBias' )
    pfloat( 'MiscInvisSlope' )
    pfloat( 'LogisticsSlope' )
    pfloat( 'MaxWeight' )
    pbool( 'EnableInitWeightRngSeed', 52, False )
    pint( 'MinInitWeightRngSeed', 52, 0 )
    pint( 'MaxInitWeightRngSeed', 52, 0 )
    pfloat( 'InitMaxWeight' )
    pfloat( 'MinBitProb' )
    pfloat( 'MaxBitProb' )
    pbool( 'SolidAgents', 31, False )
    pbool( 'SolidFood', 31, False )
    pbool( 'SolidBricks', 31, True )
    pfloat( 'AgentHeight' )
    pfloat( 'FoodHeight' )
    pcolor( 'FoodColor' )
    pfloat( 'BrickHeight', 47 )
    pcolor( 'BrickColor', 47, [0.6,0.2,0.2] )
    pfloat( 'BarrierHeight' )
    pcolor( 'BarrierColor' )
    pcolor( 'GroundColor' )
    pfloat( 'GroundClearance' )
    pcolor( 'CameraColor' )
    pfloat( 'CameraRadius' )
    pfloat( 'CameraHeight' )
    pfloat( 'CameraRotationRate' )
    pfloat( 'CameraAngleStart' )
    pfloat( 'CameraFOV' )
    pint( 'MonitorAgentRank' )
    pignore( 'MonitorCritWinWidth' )
    pignore( 'MonitorCritWinHeight' )
    pint( 'BrainMonitorStride' )
    pfloat( 'WorldSize' )

    ###
    ### Barriers
    ###
    numBarriers = pint( 'NumBarriers' )
    pbool( 'RatioBarrierPositions', 47, False )

    barriers = push( 'Barriers', Container() )
    for i in range(numBarriers):
        barrier = push( i, Container() )

        if( wfversion >= 27 ):
            numKeyFrames = pint( 'NumKeyFrames' )
            keyFrames = push( 'KeyFrames', Container() )
            for j in range(numKeyFrames):
                push( j, Container() )
                pbarrierkeyframe( j )
                pop( j )
            pop( 'KeyFrames' )
        else:
            pbarrierpos( j )

        pop( i )
    pop( 'Barriers' )

    if wfversion < 2:
        return local.container

    pbool( 'MonitorGeneSeparation' )
    pbool( 'RecordGeneSeparation' )

    if wfversion < 3:
        return local.container

    pbool( 'ChartBorn' )
    pbool( 'ChartFitness' )
    pbool( 'ChartFoodEnergy' )
    pbool( 'ChartPopulation' )
    
    ###
    ### Domains
    ###
    numDomains = pint( 'NumDomains' )

    push( 'Domains', Container() )

    for i in range(numDomains):
        domain = push( i, Container() )

        if wfversion < 32:
            pint( 'MinNumAgents' )
            pint( 'MaxNumAgents' )
            pint( 'InitNumAgents' )
            pint( 'NumberToSeed', 9, 0 )
            pfloat( 'ProbabilityOfMutatingSeeds', 9, 0.0 )

        if wfversion >= 19:
            pfloat( 'CenterX' )
            pfloat( 'CenterZ' )
            pfloat( 'SizeX' )
            pfloat( 'SizeZ' )
        
        if wfversion >= 32:
            pfloat( 'MinAgentsFraction' )
            pfloat( 'MaxAgentsFraction' )
            pfloat( 'InitAgentsFraction' )
            pfloat( 'InitSeedsFraction' )
            pfloat( 'ProbabilityOfMutatingSeeds' )
            pfloat( 'InitFoodFraction' )
            pfloat( 'MinFoodFraction' )
            pfloat( 'MaxFoodFraction' )
            pfloat( 'MaxFoodGrownFraction' )
            pfloat( 'FoodRate' )

            numFoodPatches = pint( 'NumFoodPatches' )
            numBrickPatches = pint( 'NumBrickPatches' )
        else:
            numFoodPatches = pint( 'NumFoodPatches' )
            numBrickPatches = pint( 'NumBrickPatches' )
            pfloat( 'FoodRate' )
            pint( 'InitFoodCount' )
            pint( 'MinFoodCount' )
            pint( 'MaxFoodCount' )
            pint( 'MaxFoodGrownCount' )

        foodPatches = push( 'FoodPatches', Container() )

        for j in range( numFoodPatches ):
            push( j , Container() )

            pfloat( 'FoodFraction' )

            if wfversion >= 32:
                pfloat( 'InitFoodFraction' )
                pfloat( 'MinFoodFraction' )
                pfloat( 'MaxFoodFraction' )
                pfloat( 'MaxFoodGrownFaction' )
                pfloat( 'FoodRate' )
            else:
                pfloat( 'FoodRate' )
                pint( 'InitFood' )
                pint( 'MinFood' )
                pint( 'MaxFood' )
                pint( 'MaxFoodGrown' )
            
            pfloat( 'CenterX' )
            pfloat( 'CenterY' )
            pfloat( 'SizeX' )
            pfloat( 'SizeZ' )
            penum( 'Shape', ['0','1'] )
            penum( 'Distribution', ['0','1','2'] )
            pfloat( 'NeighborhoodSize' )
            
            pint( 'Period', 26, 0 )
            pfloat( 'OnFraction', 26, 0.0 )
            pfloat( 'Phase', 26, 0.0 )
            pbool( 'RemoveFood', 26, False )

            pop( j )

        pop( 'FoodPatches' )
                

        brickPatches = push( 'BrickPatches', Container() )

        for j in range( numBrickPatches ):
            push( j, Container() )

            pfloat( 'CenterX' )
            pfloat( 'CenterZ' )
            pfloat( 'SizeX' )
            pfloat( 'SizeZ' )
            pint( 'BrickCount' )
            penum( 'Shape', ['0','1'] )
            penum( 'Distribution', ['0','1','2'] )
            pfloat( 'NeighborhoodSize' )

            pop( j )

        pop( 'BrickPatches' )
        
        pop( i )
    pop( 'Domains' )

    pbool( 'UseProbabilisticFoodPatches', 17, False )

    if wfversion < 5:
        return local.container

    pbool( 'ChartGeneSeparation' )

    if wfversion < 6:
        return local.container

    penum( 'NeuronModel', ['F','S','T'], 36, 'F' )

    pfloat( 'TauMin', 50, 0.01 )
    pfloat( 'TauMax', 50, 1.0 )
    pfloat( 'TauSeed', 50, 1.0 )

    pint( 'MinInternalNeurGroups' )
    pint( 'MaxInternalNeurGroups' )
    pint( 'MinENeurPerGroup' )
    pint( 'MaxENeurPerGroup' )
    pint( 'MinINeurPerGroup' )
    pint( 'MaxINeurPerGroup' )
    pignore( 'MinBias' )
    pfloat( 'MaxBias' )
    pfloat( 'MinBiasLrate' )
    pfloat( 'MaxBiasLrate' )
    pfloat( 'MinConnectionDensity' )
    pfloat( 'MaxConnectionDensity' )
    pfloat( 'MinTopologicalDistortion' )
    pfloat( 'MaxTopologicalDistortion' )
    pbool( 'EnableTopologicalDistortionRngSeed', 50, False )
    pint( 'MinTopologicalDistortionRngSeed', 50, 0 )
    pint( 'MaxTopologicalDistortionRngSeed', 50, 255 )
    pfloat( 'MaxNeuron2Energy' )
    pint( 'NumPreBirthCycles' )
    pfloat( 'SeedFightBias', 40, 0.5 )
    pfloat( 'SeedFightExcitation', 40, 1.0 )
    pfloat( 'SeedGiveBias', 40, 0.0 )

    if wfversion >= 39:
        pfloat( 'SeedPickupBias' )
        pfloat( 'SeedDropBias' )
        pfloat( 'SeedPickupExcitation' )
        pfloat( 'SeedDropExcitation' )

    pint( 'OverHeadRank' )
    pbool( 'AgentTracking' )
    pfloat( 'MinFoodEnergyAtDeath' )
    pbool( 'GrayCoding' )

    if wfversion < 7:
        return local.container

    penum( 'SmiteMode', ['L','R','O'], 21 )
    pfloat( 'SmiteFrac' )
    pfloat( 'SmiteAgeFrac' )

    pint( 'NumDepletionSteps', 23, 0 )
    pbool( 'ApplyLowPopulationAdvantage', 24, False )

    if wfversion < 8:
        return local.container

    pbool( 'RecordBirthsDeaths', 22, False )
    pbool( 'RecordPosition', 33, False )
    pbool( 'RecordContacts', 38, False )
    pbool( 'RecordCollisions', 38, False )
    pbool( 'RecordCarry', 42, False )

    pbool( 'BrainAnatomyRecordAll', 11, False )
    pbool( 'BrainFunctionRecordAll', 11, False )
    pbool( 'BrainAnatomyRecordSeeds', 12, False )
    pbool( 'BrainFunctionRecordSeeds', 12, False )
    pint( 'BestSoFarBrainAnatomyRecordFrequency', 11, False )
    pint( 'BestSoFarBrainFunctionRecordFrequency', 11, False )
    pint( 'BestRecentBrainAnatomyRecordFrequency', 14, False )
    pint( 'BestRecentBrainFunctionRecordFrequency', 14, False )
    pbool( 'RecordGeneStats', 12, False )
    pbool( 'RecordPerformanceStats', 35, False )
    pbool( 'RecordFoodPatchStats', 15, False )
    
    if wfversion >= 18:
        pbool( 'RecordComplexity' )
        penum( 'ComplexityType', ['0', 'P','A','I','B','D','Z'] )
        if wfversion >= 30:
            pfloat( 'ComplexityFitnessWeight' )
            pfloat( 'HeuristicFitnessWeight' )
    
    pbool( 'RecordGenomes', 37, False )
    pbool( 'RecordSeparations', 38, False )
    pbool( 'RecordAdamiComplexity', 20, False )
    pint( 'AdamiComplexityRecordFrequency', 20, 0 )

    pbool( 'CompressFiles', 54, False )

    if wfversion >= 18:
        penum( 'FogFunction', ['E','L','O'] )
        pfloat( 'ExpFogDensity' )
        pint( 'LinearFogEnd' )

    pbool( 'RecordMovie' )
    
    return local.container

#worldfile = parse( 'worldfiles/worldfile_dynfood' )
worldfile = parse( 'worldfile' )


printNewFormat( worldfile, schema = True )
