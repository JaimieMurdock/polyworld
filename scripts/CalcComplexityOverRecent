#!/usr/bin/python
### Configurable parameters
#CALC_COMPLEXITY_OVER_DIRECTORY="./CalcComplexityOverDirectory.sh"
CALC_COMPLEXITY="../utils/CalcComplexity"
OutputFilename='AvrComplexity.plt'
OutputFilename2='ComplexityHist.plt'
#### Don't modify anything beneath here unless you know what you're doing
import sys, os
### Now initialize some global variables
PASSED_DIRECTORY=''
ComplexitiesToGet='API'
NUMBINS = 11
####
def print_usage_and_exit():
	print """
        USAGE: ./CalcComplexityOverRecent Recent|bestRecent [API]

	This script takes a single argument -- a Recent or bestRecent Polyworld directory.
        Upon exiting it will leave two files, 'AvrComplexity.plt' and 'ComplexityHist.plt' in the specified
        directory with statistics on the OlafComplexity at each timestep.

	The second argument is optional.  It specifies whether you want to compute the
        average complexity of the All, Processing, or Input programs.  By default
        it calculates the OlafComplexity of all three.
	"""
	sys.exit(1)
####################################################################################
####################################################################################
def check_parameters( argv ):
	global PASSED_DIRECTORY, NUMBINS

	if len(argv) not in [1, 2]:		# if we don't have 1 or 2 parameters, exit.
		print_usage_and_exit()

	if len(argv) == 2:			# there are two arguments, meaning the CalcAll, CalcProcessing, and CalcInput are being specified.
		global ComplexitiesToGet
		ComplexitiesToGet=''	# re-initialize the default one
		if 'A' in argv[1]: ComplexitiesToGet += 'A'
		if 'P' in argv[1]: ComplexitiesToGet += 'P'
		if 'I' in argv[1]: ComplexitiesToGet += 'I'
		
		if ComplexitiesToGet == '': ComplexitiesToGet = 'API'	# get the default set
		
		argv[1] = argv[1].strip('-API')
		if argv[1].isdigit(): NUMBINS = int(argv[1])
		
	if not os.path.isfile( CALC_COMPLEXITY ):	# ensure CALC_COMPLEXITY exists.
		print "* Error: '%s' does not exist.  Fix it." %( CALC_COMPLEXITY )
		sys.exit(1)

	PASSED_DIRECTORY=argv[0].rstrip('/')		# remove the trailing slash

	if not os.path.isdir( PASSED_DIRECTORY ):	# if the passed parameter is not a directory, exit.
		print "* Error: '%s' isn't a directory." % ( PASSED_DIRECTORY )
		print_usage_and_exit()
####################################################################################
####################################################################################
# In addition to returning the median, get_median() also returns the upper and lower half of the list
# Note that this function ASSUMES THE LIST IS ALREADY SORTED.
####################################################################################
def get_median( listofnumbers ):

	length=len(listofnumbers)
	lenover2=int(length / 2)

	middle1=listofnumbers[ lenover2 ]			# this number is the answer if the length is ODD, and half of the answer is the length is EVEN
	lowerhalf=listofnumbers[: lenover2 ]	# first half of the numbers

		
	if length % 2 == 0:			# if the length of the list is an EVEN number
		upperhalf=listofnumbers[ lenover2 :]
		middle2=listofnumbers[ (lenover2 - 1) ]
		median = (middle1 + middle2) / 2.0
	else:						# the length of the list is an ODD number, so simply return the middle number.
		upperhalf=listofnumbers[(lenover2+1) :]	# second half of the numbers
		median = middle1

#	print "nums=%s" % ( listofnumbers )
#	print "median=%s" % ( median )
#	print "lowerhalf=%s" % ( lowerhalf )	
#	print "upperhalf=%s" % ( upperhalf )
	
	return median, lowerhalf, upperhalf
####################################################################################
####################################################################################
def sample_mean( list ):
        N = float(len(list))
        mean = sum(list) / N
        SSE=0
        for item in list:
                SSE += (item - mean)**2.0

        try: variance = SSE / (N-1)
        except: variance = 0

        stderr = ( variance ** 0.5 ) / (N**0.5) # stderr = stddev / sqrt(N)

        return mean, stderr
####################################################################################
####################################################################################

check_parameters(sys.argv[1:])

print "- PASSED_DIRECTORY='%s'" %(PASSED_DIRECTORY)
print "- output='%s'" % (PASSED_DIRECTORY + '/' + OutputFilename)
outputfile = open( PASSED_DIRECTORY + '/' + OutputFilename, 'w' )
if 'B' in ComplexitiesToGet:
        outputfile.write('#version=1\n')
        outputfile.write('#Timestep\tAq1\tAq2\tAq3\tAq4\tAq5\tAmean\tAstderr\tAsampsize\tPq1\tPq2\tPq3\tPq4\tPq5\tPmean\tPstderr\tPsampsize\tIq1\tIq2\tIq3\tIq4\tIq5\tImean\tIstderr\tIsampsize\tBq1\tBq2\tBq3\tBq4\tBq5\tBmean\tBstderr\tBsampsize\n')
else:
        outputfile.write('#version=0\n')
        outputfile.write('#Timestep\tAq1\tAq2\tAq3\tAq4\tAq5\tAmean\tAstderr\tAsampsize\tPq1\tPq2\tPq3\tPq4\tPq5\tPmean\tPstderr\tPsampsize\tIq1\tIq2\tIq3\tIq4\tIq5\tImean\tIstderr\tIsampsize\n')

timesteps = []
# list all of the timesteps, make sure they are all integers (and directories), then sort them by number.
for potential_timestep in os.listdir( PASSED_DIRECTORY ):
	if not potential_timestep.isdigit(): continue					# if timestep IS NOT a digit (note, 0 is considered a digit), skip.
	if not os.path.isdir( PASSED_DIRECTORY + '/' + potential_timestep ): continue	# if the timestep isn't a directory, skip it.

	timesteps.append( potential_timestep )						# add timestep to our list

timesteps = map(int, timesteps)
timesteps.sort()									# sort the timesteps, lowest numbers come first.

ALLMIN = {}
ALLMAX = {}
PROMIN = {}
PROMAX = {}
INPMIN = {}
INPMAX = {}

# We've made our timesteps, now to make our DATA containing the complexities.
DATA={ }
print "Final Timestep: %s" % ( max(timesteps) )
print "Processing:",
for t in timesteps:
	timestep_directory=PASSED_DIRECTORY + '/' + str(t)
	print '%s...' % (t),
	sys.stdout.flush()


	DATA[ str(t) + '_ALL' ] = [ ]
	DATA[ str(t) + '_PRO' ] = [ ]
	DATA[ str(t) + '_INP' ] = [ ]
	
	AlreadyHave = ''
	for c in [ 'A', 'P', 'I' ]:
		filename = timestep_directory + '/complexity_' + c + '.txt'
		if os.path.isfile( filename ):
			datafile = open(filename, 'r')
			data = datafile.readline()
			data = float(data)
			if data != -1:	# complexity of type c has already been calculated!
			print c + ' has already been calculated for this timestep. ',
			AlreadyHave += c
			datafile.close()
                        
        print "AlreadyHave =", AlreadyHave
        ComplexitiesToGet = ComplexitiesToGet.strip(AlreadyHave)
        print "ComplexitiesToGet =", ComplexitiesToGet

	if ComplexitiesToGet:
                
		for potential_brainFunction_file in os.listdir( timestep_directory ):
			if not 'brainFunction' in potential_brainFunction_file:		# if it's not a brainFunction file, skip it
				continue;

#			print "Trying file '%s'..." % ( potential_brainFunction_file )
			cmd="%s %s/%s %s" % ( CALC_COMPLEXITY, timestep_directory, potential_brainFunction_file, ComplexitiesToGet)
			CritterComplexities = os.popen(cmd).readlines()
		
			for line in CritterComplexities:
				complexity_i = line.split('\t')[1].rstrip('\n')
				if   'All'        in line :
					if 'A' in ComplexitiesToGet:
						DATA[ str(t) + '_ALL' ].append( complexity_i )
						datafile = open( timestep_directory + '/complexity_A.txt', 'a' )
						datafile.write( complexity_i + '\n' )
						datafile.flush()
						datafile.close()
				elif 'Processing' in line :
					if 'P' in ComplexitiesToGet:
						DATA[ str(t) + '_PRO' ].append( complexity_i )
						datafile = open( timestep_directory + '/complexity_P.txt', 'a' )
						datafile.write( complexity_i + '\n' )
						datafile.flush()
						datafile.close()
				elif 'Input'      in line :
					if 'I' in ComplexitiesToGet:
						DATA[ str(t) + '_INP' ].append( complexity_i )
						datafile = open( timestep_directory + '/complexity_I.txt', 'a' )
						datafile.write( complexity_i + '\n' )
						datafile.flush()
						datafile.close()
				else:
					print "* Error: The output of CalcComplexity has been modified in an incompatible way."
					sys.exit(1)
				
	for c in AlreadyHave:
		datafile = open( timestep_directory + '/complexity_' + c + '.txt', 'r' )
		if c == 'A': thistype = str(t) + '_ALL'
		elif c == 'P': thistype = str(t) + '_PRO'
		else: thistype = str(t) + '_INP'
		for line in datafile:
			DATA[ thistype ].append( line.rstrip('\n') )

	list_to_print = [ t ]				# begin the line with timestep t
# This loop doesn't do anything vital to the logic, it is solely for cleanup and prepartion for the next loop
	for keypiece in ( '_ALL', '_PRO', '_INP' ):
		DATAkey = str(t) + keypiece
		DATA[ DATAkey ] = map( float, DATA[ DATAkey ] ) # convert to floats just to make sure we're going to sort right.
		DATA[ DATAkey ].sort()
		while DATA[ DATAkey ].count(0.0): DATA[ DATAkey ].remove(0.0)	# remove any 0.0 from the list.  (0.0 means the critter didnt live long enough, so dont include it)

#		print "list=%s" % ( list_to_print )

		DATAkey = str(t) + keypiece
#		print "DATA[%s]=%s" % ( DATAkey, DATA[DATAkey] )
		try:
			minimum=min( DATA[ DATAkey ] )
			maximum=max( DATA[ DATAkey ] )

#			if keypiece == '_ALL':
#				ALLMAX[ str(t) ] = maximum
#				ALLMIN[ str(t) ] = minimum
#			elif keypiece == '_PRO':
#				PROMAX[ str(t) ] = maximum
#				PROMIN[ str(t) ] = minimum
#			else:
#				INPMAX[ str(t) ] = maximum
#				INPMIN[ str(t) ] = minimum

			mean, mean_stderr = sample_mean( DATA[ DATAkey ] )
			median,lowerhalf,upperhalf=get_median( DATA[ DATAkey ] )
			q1=get_median( lowerhalf )[0]
			q3=get_median( upperhalf )[0]
		except ValueError:
			minimum, maximum, mean, mean_stderr, q1, q3, median = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)

		if keypiece == '_ALL':
			ALLMAX[ str(t) ] = maximum
			ALLMIN[ str(t) ] = minimum
		elif keypiece == '_PRO':
			PROMAX[ str(t) ] = maximum
			PROMIN[ str(t) ] = minimum
		else:
			INPMAX[ str(t) ] = maximum
			INPMIN[ str(t) ] = minimum

		list_to_print.append( "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" % ( minimum, q1, median, q3, maximum, mean, mean_stderr, len( DATA[DATAkey] ) ) )
#		del DATA[ str(t) + keypiece ]		# delete the timestep, we dont need it anymore.
#		del DATA[ DATAkey ]			# delete the raw data, we don't need it anymore.
#		print "list=%s" % ( list_to_print )
#		print "%s\t%s\t%s\t%s\t%s\t%s\t%s" % ( minimum, q1, median, q3, maximum, mean, mean_stderr )

	list_to_print = map(str, list_to_print)
	outputfile.write( '\t'.join( list_to_print ) )
	outputfile.write('\n')				
	outputfile.flush()

outputfile.close()

# begin writing the next outputfile
outputfile = open( PASSED_DIRECTORY + '/' + OutputFilename2.replace( '.', 'Norm.'), 'w' )
outputfile.write('#version=1\n#numbins=%s\n' % (NUMBINS) )

BINS = { }

for t in timesteps:
	BINS[ str(t) + '_ALL' ] = [ ]
	for i in range(NUMBINS):
		BINS[ str(t) + '_ALL' ].append(0)
	BINS[ str(t) + '_PRO' ] = [ ]
	for i in range(NUMBINS):
		BINS[ str(t) + '_PRO' ].append(0)
	BINS[ str(t) + '_INP' ] = [ ]
	for i in range(NUMBINS):
		BINS[ str(t) + '_INP' ].append(0)

	if ALLMAX[ str(t) ] > ALLMIN[ str(t) ]:
		for crittercomplexity in DATA[ str(t) + '_ALL' ]:
			thisbin = int(((crittercomplexity - ALLMIN[ str(t) ])/(ALLMAX[ str(t) ] - ALLMIN[ str(t) ]))*NUMBINS)
			if thisbin >= NUMBINS: thisbin -= 1
			BINS[ str(t) + '_ALL' ][ thisbin ]  += 1
	if PROMAX[ str(t) ] > PROMIN[ str(t) ]:
		for crittercomplexity in DATA[ str(t) + '_PRO' ]:
			thisbin = int(((crittercomplexity - PROMIN[ str(t) ])/(PROMAX[ str(t) ] - PROMIN[ str(t) ]))*NUMBINS)
			if thisbin >= NUMBINS: thisbin -= 1
			BINS[ str(t) + '_PRO' ][ thisbin ]  += 1
	if INPMAX[ str(t) ] > INPMIN[ str(t) ]:
		for crittercomplexity in DATA[ str(t) + '_INP' ]:
			thisbin = int(((crittercomplexity - INPMIN[ str(t) ])/(INPMAX[ str(t) ] - INPMIN[ str(t) ]))*NUMBINS)
			if thisbin >= NUMBINS: thisbin -= 1
			BINS[ str(t) + '_INP' ][ thisbin ]  += 1

ALLTOTAL = {}
PROTOTAL = {}
INPTOTAL = {}
for t in timesteps:	# t= 0, 1000, 2000,...
	ALLTOTAL[ str(t) ] = 0
	PROTOTAL[ str(t) ] = 0
	INPTOTAL[ str(t) ] = 0

for t in timesteps:
	for bincount in BINS[ str(t) + '_ALL' ]:
		ALLTOTAL[ str(t) ] += bincount
	for bincount in BINS[ str(t) + '_PRO' ]:
		PROTOTAL[ str(t) ] += bincount
	for bincount in BINS[ str(t) + '_INP' ]:
		INPTOTAL[ str(t) ] += bincount

for t in timesteps:
	if ALLTOTAL[ str(t) ]:
		outputfile.write('%s\t' % (t))
		for bincount in BINS[ str(t) + '_ALL' ]:
			outputfile.write('%s\t' % (100*bincount/ALLTOTAL[ str(t) ]))

outputfile.write('\n')
for t in timesteps:
	if PROTOTAL[ str(t) ]:
		outputfile.write('%s\t' % (t))
		for bincount in BINS[ str(t) + '_PRO' ]:
			outputfile.write('%s\t' % (100*bincount/PROTOTAL[ str(t) ]))

outputfile.write('\n')
for t in timesteps:
	if INPTOTAL[ str(t) ]:
		outputfile.write('%s\t' % (t))
		for bincount in BINS[ str(t) + '_INP' ]:
			outputfile.write('%s\t' % (100*bincount/INPTOTAL[ str(t) ]))

outputfile.flush()
outputfile.close()

outputfile = open( PASSED_DIRECTORY + '/' + OutputFilename2.replace( '.', 'Raw.'), 'w' )
outputfile.write('#version=1\n#numbins=%s\n' % (NUMBINS) )

ALLMAXGLOBAL = ALLMAX[ '0' ]
ALLMINGLOBAL = ALLMIN[ '0' ]
PROMAXGLOBAL = PROMAX[ '0' ]
PROMINGLOBAL = PROMIN[ '0' ]
INPMAXGLOBAL = INPMAX[ '0' ]
INPMINGLOBAL = INPMIN[ '0' ]

for t in timesteps:
	if ALLMAX[ str(t) ] > ALLMAXGLOBAL: ALLMAXGLOBAL = ALLMAX[ str(t) ]
	if ALLMIN[ str(t) ] < ALLMINGLOBAL: ALLMINGLOBAL = ALLMIN[ str(t) ]
	if PROMAX[ str(t) ] > PROMAXGLOBAL: PROMAXGLOBAL = PROMAX[ str(t) ]
	if PROMIN[ str(t) ] < PROMINGLOBAL: PROMINGLOBAL = PROMIN[ str(t) ]
	if INPMAX[ str(t) ] > INPMAXGLOBAL: INPMAXGLOBAL = INPMAX[ str(t) ]
	if INPMIN[ str(t) ] < INPMINGLOBAL: INPMINGLOBAL = INPMIN[ str(t) ]

outputfile.write('#ALLMAX=%s\n#PROMAX=%s\n#INPMAX=%s\n' % (ALLMAXGLOBAL, PROMAXGLOBAL, INPMAXGLOBAL))

BINS = { }

for t in timesteps:
	BINS[ str(t) + '_ALL' ] = [ ]
	for i in range(NUMBINS):
		BINS[ str(t) + '_ALL' ].append(0)
	BINS[ str(t) + '_PRO' ] = [ ]
	for i in range(NUMBINS):
		BINS[ str(t) + '_PRO' ].append(0)
	BINS[ str(t) + '_INP' ] = [ ]
	for i in range(NUMBINS):
		BINS[ str(t) + '_INP' ].append(0)

	if ALLMAXGLOBAL > ALLMINGLOBAL:
		for crittercomplexity in DATA[ str(t) + '_ALL' ]:
			thisbin = int(((crittercomplexity - ALLMINGLOBAL)/(ALLMAXGLOBAL - ALLMINGLOBAL))*NUMBINS)
			if thisbin >= NUMBINS: thisbin -= 1
			BINS[ str(t) + '_ALL' ][ thisbin ]  += 1
	if PROMAXGLOBAL > PROMINGLOBAL:
		for crittercomplexity in DATA[ str(t) + '_PRO' ]:
			thisbin = int(((crittercomplexity - PROMINGLOBAL)/(PROMAXGLOBAL - PROMINGLOBAL))*NUMBINS)
			if thisbin >= NUMBINS: thisbin -= 1
			BINS[ str(t) + '_PRO' ][ thisbin ]  += 1
	if INPMAXGLOBAL > INPMINGLOBAL:
		for crittercomplexity in DATA[ str(t) + '_INP' ]:
			thisbin = int(((crittercomplexity - INPMINGLOBAL)/(INPMAXGLOBAL - INPMINGLOBAL))*NUMBINS)
			if thisbin >= NUMBINS: thisbin -= 1
			BINS[ str(t) + '_INP' ][ thisbin ]  += 1

for t in timesteps:
	if ALLTOTAL[ str(t) ]:
		outputfile.write('%s\t' % (t))
		for bincount in BINS[ str(t) + '_ALL' ]:
			outputfile.write('%s\t' % (100*bincount/ALLTOTAL[ str(t) ]))

outputfile.write('\n')
for t in timesteps:
	if PROTOTAL[ str(t) ]:
		outputfile.write('%s\t' % (t))
		for bincount in BINS[ str(t) + '_PRO' ]:
			outputfile.write('%s\t' % (100*bincount/PROTOTAL[ str(t) ]))

outputfile.write('\n')
for t in timesteps:
	if INPTOTAL[ str(t) ]:
		outputfile.write('%s\t' % (t))
		for bincount in BINS[ str(t) + '_INP' ]:
			outputfile.write('%s\t' % (100*bincount/INPTOTAL[ str(t) ]))

outputfile.flush()
outputfile.close()

print "Done!"

