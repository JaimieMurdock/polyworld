/********************************************************************/
/* PolyWorld:  An Artificial Life Ecological Simulator              */
/* by Larry Yaeger                                                  */
/* Copyright Apple Computer 1990,1991,1992                          */
/********************************************************************/

// brick.cp - implementation of bricks

// Self
#include "brick.h"

// System
#include <ostream>

// qt
#include <qapplication.h>

// Local
#include "critter.h"
#include "globals.h"
#include "graphics.h"


using namespace std;

// External globals
float brick::gBrickHeight;
Color brick::gBrickColor;

//===========================================================================
// bricks
//===========================================================================


//-------------------------------------------------------------------------------------------
// brick::brick
//-------------------------------------------------------------------------------------------
brick::brick()
{
	setType(BRICKTYPE);
	initbrick();
}


//-------------------------------------------------------------------------------------------
// brick::brick
//-------------------------------------------------------------------------------------------
brick::brick(float e)
{
	initbrick(e);
}


//-------------------------------------------------------------------------------------------
// brick::brick
//-------------------------------------------------------------------------------------------
brick::brick(float e, float x, float z)
{
	initbrick(e, x, z);
}


//-------------------------------------------------------------------------------------------
// brick::~brick
//-------------------------------------------------------------------------------------------
brick::~brick()
{
}


//-------------------------------------------------------------------------------------------
// brick::dump
//-------------------------------------------------------------------------------------------
void brick::dump(ostream& out)
{
    out << fEnergy nl;
    out << fPosition[0] sp fPosition[1] sp fPosition[2] nl;
}


//-------------------------------------------------------------------------------------------
// brick::load
//-------------------------------------------------------------------------------------------
void brick::load(istream& in)
{
    in >> fEnergy;
    in >> fPosition[0] >> fPosition[1] >> fPosition[2];

    initlen();
}



//-------------------------------------------------------------------------------------------
// brick::initbrick
//-------------------------------------------------------------------------------------------
void brick::initbrick()
{
	requiredEnergy = drand48() * (gMaxBrickEnergy - gMinBrickEnergy) + gMinBrickEnergy;
	initlen();
	initpos();
	initrest();
}


//-------------------------------------------------------------------------------------------
// brick::initbrick
//-------------------------------------------------------------------------------------------
void brick::initbrick(float e)
{
	fEnergy = e;
	initlen();
	initpos();
	initrest();
}


//-------------------------------------------------------------------------------------------
// brick::initbrick
//-------------------------------------------------------------------------------------------
void brick::initbrick(float e, float x, float z)
{
	fEnergy = e;
	initlen();
	fPosition[0] = x;
	fPosition[1] = 0.5 * fLength[1];
	fPosition[2] = z;
	initrest();
}
 

//-------------------------------------------------------------------------------------------
// brick::initpos
//-------------------------------------------------------------------------------------------    
void brick::initpos()
{
	fPosition[0] = drand48() * globals::worldsize;
	fPosition[1] = 0.5 * fLength[1];
	fPosition[2] = drand48() * globals::worldsize;
}


//-------------------------------------------------------------------------------------------
// brick::initlen
//-------------------------------------------------------------------------------------------       
void brick::initlen()
{
	float lxz = 0.75 * fEnergy / gSize2Energy;
	float ly = gBrickHeight;
	setlen(lxz,ly,lxz);
}


//-------------------------------------------------------------------------------------------
// brick::initrest
//-------------------------------------------------------------------------------------------           
void brick::initrest()
{
	setcolor(gBrickColor);
}


//-------------------------------------------------------------------------------------------
// brick::setenergy
//-------------------------------------------------------------------------------------------           
void brick::setenergy(float e)
{
	fEnergy = e;
	initlen();
}


//-------------------------------------------------------------------------------------------
// brick::setradius
//-------------------------------------------------------------------------------------------           
void brick::setradius()
{
	if( !fRadiusFixed )  //  only set radius anew if not set manually
		fRadius = sqrt( fLength[0]*fLength[0] + fLength[2]*fLength[2] ) * fRadiusScale * fScale * 0.5;
	srPrint( "brick::%s(): r=%g%s\n", __FUNCTION__, fRadius, fRadiusFixed ? "(fixed)" : "" );
}

